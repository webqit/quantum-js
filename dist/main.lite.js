(()=>{var Ut=Object.defineProperty;var ee=(n,t,e)=>t in n?Ut(n,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[t]=e;var bt=(n,t)=>{for(var e in t)Ut(n,e,{get:t[e],enumerable:!0})};var N=(n,t,e)=>(ee(n,typeof t!="symbol"?t+"":t,e),e);var Lt={};bt(Lt,{AsyncQuantumFunction:()=>te,AsyncQuantumScript:()=>et,Observer:()=>y,QuantumAsyncFunction:()=>Re,QuantumAsyncScript:()=>qe,QuantumFunction:()=>Ce,QuantumModule:()=>lt,QuantumScript:()=>Me,State:()=>H});var Ft={};bt(Ft,{any:()=>_e,apply:()=>jt,batch:()=>Dt,construct:()=>St,defineProperties:()=>Ae,defineProperty:()=>ot,deleteProperties:()=>Ee,deleteProperty:()=>st,get:()=>F,getOwnPropertyDescriptor:()=>yt,getOwnPropertyDescriptors:()=>Oe,getPrototypeOf:()=>$t,has:()=>gt,intercept:()=>ve,isExtensible:()=>kt,map:()=>Pe,observe:()=>qt,ownKeys:()=>Tt,path:()=>be,preventExtensions:()=>Rt,reduce:()=>Mt,set:()=>B,setPrototypeOf:()=>Ct,subtree:()=>we});function P(n){return!Array.isArray(n)&&typeof n=="object"&&n}function X(n){return typeof n}function S(n){return Array.isArray(n)}function Y(n){return typeof n=="function"}function wt(n){return n===null||n===""}function U(n){return arguments.length&&(n===void 0||typeof n>"u")}function A(n){return Array.isArray(n)||typeof n=="object"&&n||Y(n)}function _t(n){return wt(n)||U(n)||n===!1||n===0||A(n)&&!Object.keys(n).length}function M(n){return Y(n)||n&&{}.toString.call(n)==="[object function]"}function pt(n){return n instanceof String||typeof n=="string"&&n!==null}function vt(n){return!pt(n)&&!U(n.length)}function mt(n,...t){if(!n||!["object","function"].includes(typeof n))throw new Error("Argument #1 must be of type object");let e=n[Symbol.for("wq")];if(e||(e=new ht,Object.defineProperty(n,Symbol.for("wq"),{value:e,enumerable:!1,configurable:!1,writable:!1})),!t.length)return e;let r,i;for(;r=t.shift();)(i=e)&&!(e=e.get(r))&&(e=new ht,i.set(r,e));return e}var ht=class extends Map{};function z(n,t=!0){return S(n)?n:!t&&P(n)?[n]:n!==!1&&n!==0&&_t(n)?[]:vt(n)?Array.prototype.slice.call(n):P(n)?Object.values(n):[n]}var _=(n,...t)=>mt(n,"observerAPI",...t),Z=(n,t)=>n instanceof Promise?n.then(t):t(n),dt={};var V=class{constructor(t,e){this.registry=t,Object.assign(this,{...e,target:t.target}),this.params.signal&&this.params.signal.addEventListener("abort",()=>this.remove())}remove(){return this.removed=!0,this.registry.removeRegistration(this)}};var rt=class extends V{constructor(){super(...arguments),this.emit.currentRegistration=this,Object.defineProperty(this,"abortController",{value:new AbortController}),Object.defineProperty(this,"signal",{value:this.abortController.signal}),dt.setMaxListeners?.(0,this.signal)}remove(){this.abortController.abort(),super.remove()}fire(t){if(this.emit.recursionTarget&&!["inject","force-async","force-sync"].includes(this.params.recursions))return;let e=t,r=this.filter;if(r!==1/0&&(r=z(r,!1))&&(e=t.filter(o=>r.includes(o.key))),this.params.diff&&(e=e.filter(o=>o.type!=="set"||o.value!==o.oldValue)),!e.length)return;if(["inject","defer"].includes(this.params.recursions)){if(this.emit.recursionTarget){this.emit.recursionTarget.push(...e);return}this.emit.recursionTarget=this.params.recursions==="inject"?e:[]}let i=this.filter===1/0||Array.isArray(this.filter)?this.emit(e,this):this.emit(e[0],this);return Z(i,o=>{let a=this.emit.recursionTarget;return delete this.emit.recursionTarget,this.params.recursions==="defer"&&a?.length?this.emit.currentRegistration.fire(a):o})}};var T=class{constructor(t){this.target=t,this.entries=[]}addRegistration(t){return this.entries.push(t),t}removeRegistration(t){this.entries=this.entries.filter(e=>e!==t)}static _getInstance(t,e,r=!0,i=this.__namespace){if(!A(e))throw new Error(`Subject must be of type object; "${X(e)}" given!`);let o=this;return i&&_(T,"namespaces").has(t+"-"+i)&&(o=_(T,"namespaces").get(t+"-"+i),t+="-"+i),!_(e,"registry").has(t)&&r&&_(e,"registry").set(t,new o(e)),_(e,"registry").get(t)}static _namespace(t,e,r=null){if(t+="-"+e,arguments.length===2)return _(T,"namespaces").get(t);if(!(r.prototype instanceof this))throw new Error(`The implementation of the namespace ${this.name}.${e} must be a subclass of ${this.name}.`);_(T,"namespaces").set(t,r),r.__namespace=e}};var O=class{constructor(t,e){if(this.target=t,!e.operation)throw new Error("Descriptor operation must be given in definition!");Object.assign(this,e)}};var q=class extends T{static getInstance(t,e=!0,r=null){return super._getInstance("listeners",...arguments)}static namespace(t,e=null){return super._namespace("listeners",...arguments)}constructor(t){super(t),this.batches=[]}addRegistration(t,e,r){return super.addRegistration(new rt(this,{filter:t,emit:e,params:r}))}emit(t,{eventsArePropertyDescriptors:e=!1,eventIsArrayMethodDescriptor:r=!1}={}){if(this.batches.length){let i=this.batches[0].params.arrayMethodName;this.batches[0].snapshots.push({events:[...t],arrayMethodName:i,eventsArePropertyDescriptors:e,eventIsArrayMethodDescriptor:r});return}this.$emit(this.entries,[{events:t,eventsArePropertyDescriptors:e,eventIsArrayMethodDescriptor:r}])}$emit(t,e){let r=0,i=0,o=0;for(let c of t)r+=1,c.params.withPropertyDescriptors&&(i+=1),c.params.withArrayMethodDescriptors&&(o+=1);let a=[],s=[],f=[],u=[];for(let c of e){let l=c.arrayMethodName,m=c.eventsArePropertyDescriptors,x=c.eventIsArrayMethodDescriptor;for(let p of c.events)if(l&&(p.operation=l),i&&(o&&a.push(p),x||o!==r&&s.push(p)),i!==r){let w=p;if(m){let{target:b,type:g,...d}=p;w=new O(b,{type:"set",...d}),Object.defineProperty(w,"value","get"in d.value?{get:()=>d.value.get()}:{value:d.value.value}),d.oldValue&&Object.defineProperty(w,"oldValue","get"in d.oldValue?{get:()=>d.oldValue.get()}:{value:d.oldValue.value})}o&&f.push(w),x||o!==r&&u.push(w)}}for(let c of t)c.params.withPropertyDescriptors?c.params.withArrayMethodDescriptors?a.length&&c.fire(a):s.length&&c.fire(s):c.params.withArrayMethodDescriptors?f.length&&c.fire(f):u.length&&c.fire(u)}batch(t,e={}){this.batches.unshift({entries:[...this.entries],snapshots:[],params:e});let r=t();return Z(r,i=>{let o=this.batches.shift();return o.snapshots.length&&this.$emit(o.entries,o.snapshots),i})}};var nt=class extends V{exec(t,e,r){return this.running||!this.traps[t.operation]?e(...Array.prototype.slice.call(arguments,2)):(this.running=!0,this.traps[t.operation](t,r,(...i)=>(this.running=!1,e(...i))))}};var D=class extends T{static getInstance(t,e=!0,r=null){return super._getInstance("traps",...arguments)}static namespace(t,e=null){return super._namespace("traps",...arguments)}addRegistration(t){return super.addRegistration(new nt(this,t))}emit(t,e=null){let r=this;return function i(o,...a){let s=r.entries[o];return s?s.exec(t,(...f)=>i(o+1,...f),...a):e?e(t,...a):a[0]}(0)}};var Et={};bt(Et,{accessorize:()=>ge,proxy:()=>Ht,unaccessorize:()=>xe,unproxy:()=>it});var Gt=Symbol("wqOriginal");function ge(n,t,e={}){n=At(n);let r=_(n,"accessorizedProps");function i(f){let u,c=n;do u=Object.getOwnPropertyDescriptor(c,f);while(!u&&(c=Object.getPrototypeOf(c)));return u?{proto:c,descriptor:u}:{descriptor:{value:void 0,configurable:!0,enumerable:!0,writable:!0}}}function o(f){if(r.has(f+""))return!0;let u=i(f);u.getValue=function(m=!1){return m?this.descriptor:this.descriptor.get?this.descriptor.get():this.descriptor.value},u.setValue=function(m,x=!1){if(this.dirty=!0,x){this.descriptor=m;return}return this.descriptor.set?this.descriptor.set(m)!==!1:(this.descriptor.value=m,!0)},u.intact=function(){let m=Object.getOwnPropertyDescriptor(n,f);return m?.get===l.get&&m?.set===l.set&&r.get(f+"")===this},u.restore=function(){return this.intact()?(this.proto&&this.proto!==n||!this.proto&&!this.dirty?delete n[f]:Object.defineProperty(n,f,this.descriptor),r.delete(f+""),!0):!1},r.set(isNaN(f)?f:parseInt(f),u);let{enumerable:c=!0}=u.descriptor,l={enumerable:c,configurable:!0};("value"in u.descriptor||u.descriptor.set)&&(l.set=function(m){return B(this,f,m,e)}),("value"in u.descriptor||u.descriptor.get)&&(l.get=function(){return F(this,f,e)});try{return Object.defineProperty(n,f,l),!0}catch{return r.delete(f+""),!1}}let s=(Array.isArray(t)?t:t===void 0?Object.keys(n):[t]).map(o);return t===void 0||Array.isArray(t)?s:s[0]}function xe(n,t,e={}){n=At(n);let r=_(n,"accessorizedProps");function i(s){return r.has(s+"")?r.get(s+"").restore():!0}let a=(Array.isArray(t)?t:t===void 0?Object.keys(n):[t]).map(i);return t===void 0||Array.isArray(t)?a:a[0]}function Ht(n,t={},e=void 0){let r=At(n);if(typeof t.membrane=="boolean")throw new Error("The params.membrane parameter cannot be of type boolean.");if(t.membrane&&_(r,"membraneRef").has(t.membrane))return _(r,"membraneRef").get(t.membrane);let i={apply:(s,f,u)=>jt(s,f,u,void 0,t),construct:(s,f,u=null)=>St(s,f,u,t),defineProperty:(s,f,u)=>ot(s,f,u,t),deleteProperty:(s,f)=>st(s,f,t),get:(s,f,u=null)=>{if(f===Gt)return r;let c={...t,receiver:u},l=F(s,f,c);return Array.isArray(s)&&typeof l=="function"?Ht(l,{...t,arrayMethodName:f,membrane:u}):l},getOwnPropertyDescriptor:(s,f)=>yt(s,f,t),getPrototypeOf:s=>$t(s,t),has:(s,f)=>gt(s,f,t),isExtensible:s=>kt(s,t),ownKeys:s=>Tt(s,t),preventExtensions:s=>Rt(s,t),set:(s,f,u,c=null)=>B(s,f,u,{...t,receiver:c}),setPrototypeOf:(s,f)=>Ct(s,f,t)},o=e?.(i)||i,a=new Proxy(r,o);return t.membrane&&_(r,"membraneRef").set(t.membrane,a),a}function it(n){return n&&n[Gt]||n}function At(n){if(!n||!A(n))throw new Error("Target must be of type object!");return it(n)}var at=class extends Array{};function be(...n){return new at(...n)}var W=class extends Array{};function we(){return new W}function _e(){return 1/0}function Mt(n,t,e,r=o=>o,i={}){let o=t instanceof W;if(!(!o&&!t?.length))return function a(s,f,u,c){let l=c||f[u.level]instanceof W,m=l?1/0:f[u.level],x=l?!1:u.level===f.length-1;return s instanceof O&&s.operation!=="get"?u={...u,probe:"always"}:u.probe!=="always"&&(u={...u,probe:!x}),e(s,m,(p,...w)=>{let b=h=>{h instanceof O&&(h.path="key"in h?[h.key]:[],s instanceof O&&(h.path="key"in h?s.path.concat(h.key):s.path.slice(0),Object.defineProperty(h,"context",{get:()=>s,configurable:!0})))},g=w[0]||{},d=h=>{if(h instanceof O&&"argumentsList"in h)return;let E=C(h,!1);return Z(E,v=>(h instanceof O?h.value=v:h=v,a(h,f,{...u,...g,keyInParent:h.key,level:u.level+1},l)))};if(ut(m)&&Array.isArray(p)){if(p.forEach(b),x)return r(p,...w);l&&p[0]instanceof O&&(p[0].operation!=="get"||i.asGet)&&r(p,...w);for(let h of p)d(h);return}return b(p),x?r(p,...w):d(p)},u)}(n,t.slice(0),{...i,level:0},o)}function qt(n,t,e,r={}){let i=C(n,!r.level);if(M(arguments[1])&&([,e,r={}]=arguments,t=1/0),!M(e))throw new Error(`Handler must be a function; "${X(e)}" given!`);if(t instanceof at||t instanceof W)return Mt(i,t,qt,e,r);if(r={...r,descripted:!0},delete r.live,!A(i))return r.probe&&F(i,t,e,r)||void 0;let o=Jt(i,t,e,r);return r.probe?F(i,t,o,r):o()}function ve(n,t,e={}){let r=C(n);return P(t)||([,,,e={}]=arguments,t={[arguments[1]]:arguments[2]}),D.getInstance(r,!0,e.namespace).addRegistration({traps:t,params:e})}function yt(n,t,e=i=>i,r={}){return j(n,"getOwnPropertyDescriptor",{key:t},e,r)}function Oe(n,t,e=i=>i,r={}){return j(n,"getOwnPropertyDescriptors",{key:t},e,r)}function $t(n,t=r=>r,e={}){return j(n,"getPrototypeOf",{},t,e)}function kt(n,t=r=>r,e={}){return j(n,"isExtensible",{},t,e)}function Tt(n,t=r=>r,e={}){return j(n,"ownKeys",{},t,e)}function gt(n,t,e=i=>i,r={}){return j(n,"has",{key:t},e,r)}function F(n,t,e=i=>i,r={}){let i,o=C(n,!r.level);return P(e)?[r,e]=[e,a=>a]:r.live&&(i=!0),t instanceof at||t instanceof W?Mt(o,t,F,e,{...r,asGet:!0}):$e(o,t,a=>{let s=[...a];return function f(u,c,l){if(!c.length)return l(u);let m=c.shift();if(!["string","number","symbol"].includes(typeof m))throw new Error(`Property name/key ${m} invalid.`);function x(b,g=void 0){let d=v=>(b.value=v,f([...u,r.live||r.descripted?b:v],c,l));if(arguments.length>1)return d(g);if(!A(o))return d(o?.[b.key]);let h=_(o,"accessorizedProps",!1),E=h&&h.get(b.key);if(E&&E.intact())return d(E.getValue(r.withPropertyDescriptors));if(r.withPropertyDescriptors){let v=Object.getOwnPropertyDescriptor(o,b.key);return d(v)}return d(Reflect.get(o,b.key))}let p=new O(o,{type:"get",key:m,value:void 0,operation:"get",related:s});if(!A(o))return x(p);let w=D.getInstance(o,!1,r.namespace);return w?w.emit(p,x):x(p)}([],a.slice(0),f=>{let u=ut(t)?f:f[0];return i&&A(o)?Jt(o,t,e,r,n.key)(u):e(u)})},r)}function Dt(n,t,e={}){let r=C(n);return q.getInstance(r,!0,e.namespace).batch(t,e)}function Pe(n,t,e={}){t=C(t),n=C(n);let r=(e.only||[]).slice(0),i=(e.except||[]).slice(0),o=Object.keys(e.spread?[...n]:n).map(u=>isNaN(u)?u:parseInt(u)),a=r.length?r.filter(u=>o.includes(u)):o.filter(u=>!i.includes(u)),s=u=>!Array.isArray(t)||isNaN(u)?u:u-i.filter(c=>c<u).length,f=u=>{let c=yt(n,u,e);"value"in c&&c.writable&&c.enumerable&&c.configurable?B(t,s(u),c.value,e):(c.enumerable||e.onlyEnumerable===!1)&&ot(t,u,{...c,configurable:!0},e)};return Dt(t,()=>{a.forEach(f)}),qt(n,u=>{u.filter(c=>r.length?r.includes(c.key):!i.includes(c.key)).forEach(c=>{if(c.type==="delete")return st(t,s(c.key),e);if(c.type==="def"){(c.value.enumerable||e.onlyEnumerable===!1)&&ot(t,s(c.key),{...c.value,configurable:!0},e);return}f(c.key)})},{...e,withPropertyDescriptors:!0})}function B(n,t,e,r=a=>a,i={},o=!1){let a=C(n),s=[[t,e]];P(t)&&([,,r=u=>u,i={},o=!1]=arguments,s=Object.entries(t)),P(r)&&([o,i,r]=[typeof i=="boolean"?i:o,r,u=>u]);let f=s.map(([u])=>u);return function u(c,l,m){if(!l.length)return m(c);let[x,p]=l.shift();function w(g,d=void 0){let h=I=>(g.status=I,u(c.concat(g),l,m));if(arguments.length>1)return h(g,d);let E=_(a,"accessorizedProps",!1),v=E&&E.get(g.key);return g.type==="def"?(v&&!v.restore()&&h(!1),Object.defineProperty(a,g.key,g.value),h(!0)):v&&v.intact()?h(v.setValue(g.value)):h(Reflect.set(a,g.key,g.value))}function b(g,d){if(i.diff&&p===d)return u(c,l,m);let h=new O(a,{type:o?"def":"set",key:x,value:p,isUpdate:g,oldValue:d,related:[...f],operation:o?"defineProperty":"set",detail:i.detail}),E=D.getInstance(a,!1,i.namespace);return E?E.emit(h,w):w(h)}return gt(a,x,g=>{if(!g)return b(g);if(x==="length"&&Array.isArray(a)&&_(a).has("$length"))return b(!0,_(a).get("$length"));let d={...i,withPropertyDescriptors:o};return F(a,x,h=>b(g,h),d)},i)}([],s.slice(0),u=>{let c=q.getInstance(a,!1,i.namespace);return c&&c.emit(u,{eventsArePropertyDescriptors:!!o}),r(ut(t)?u.map(l=>l.status):u[0]?.status)})}function ot(n,t,e,r=o=>o,i={}){return B(n,t,e,r,i,!0)}function Ae(n,t,e=i=>i,r={}){return B(n,t,e,r,!0)}function st(n,t,e=i=>i,r={}){let i=C(n);P(e)&&([r,e]=[e,s=>s]);let o=z(t,!1),a=[...o];return function s(f,u,c){if(!u.length)return c(f);let l=u.shift();function m(p,w=void 0){let b=h=>(p.status=h,s(f.concat(p),u,c));if(arguments.length>1)return b(p,w);let g=_(i,"accessorizedProps",!1),d=g&&g.get(p.key);return d&&!d.restore()&&b(!1),b(Reflect.deleteProperty(i,p.key))}function x(p){let w=new O(i,{type:"delete",key:l,oldValue:p,related:[...a],operation:"deleteProperty",detail:r.detail}),b=D.getInstance(i,!1,r.namespace);return b?b.emit(w,m):m(w)}return F(i,l,x,r)}([],o.slice(0),s=>{let f=q.getInstance(i,!1,r.namespace);return f&&f.emit(s),e(ut(t)?s.map(u=>u.status):s[0].status)})}function Ee(n,t,e=i=>i,r={}){return st(...arguments)}function St(n,t,e=null,r=o=>o,i={}){return j(n,"construct",arguments.length>2?{argumentsList:t,newTarget:e}:{argumentsList:t},r,i)}function jt(n,t,e,r=o=>o,i={}){let o=it(t),a;if(Array.isArray(t)){if(i.arrayMethodName){let s=new O(o,{operation:i.arrayMethodName,argumentsList:e});q.getInstance(o,!1,i.namespace)?.emit([s],{eventIsArrayMethodDescriptor:!0})}_(o).set("$length",o.length),a=Dt(o,()=>j(n,"apply",{thisArgument:t,argumentsList:e},r,i),i),_(o).delete("$length")}else a=j(n,"apply",{thisArgument:o,argumentsList:e},r,i);return a}function Ct(n,t,e=i=>i,r={}){return j(n,"setPrototypeOf",{proto:t},e,r)}function Rt(n,t=r=>r,e={}){return j(n,"preventExtensions",{},t,e)}function Jt(n,t,e,r={}){let i=new AbortController;dt.setMaxListeners?.(0,i.signal),r.signal&&r.signal.addEventListener("abort",()=>i.abort());let o={...r,signal:i.signal},a=q.getInstance(n,!0,o.namespace),s=new Map;return function f(u=[],c=null){let l,m,x;if(ut(t)){if(c){x=!0,m=c;for(let p of u)s.get(p.key)?.remove(),s.delete(p.key)}else m=a.addRegistration(t,f,o);l={signal:m.signal,childRegistrations:s}}else c?.remove(),m=a.addRegistration(t,f,o),l={signal:m.signal};if(o.childRegistrations&&o.keyInParent&&o.childRegistrations.set(o.keyInParent,m),arguments.length){let p=e(u,l);if(arguments.length>1)return p}return i}}function j(n,t,e={},r=o=>o,i={}){n=C(n),P(r)&&([i,r]=[r,f=>f]);function o(f,u){return arguments.length>1?r(u):r((Reflect[t]||Object[t])(n,...Object.values(e)))}let a=new O(n,{operation:t,...e}),s=D.getInstance(n,!1,i.namespace);return s?s.emit(a,o):o(a)}function ut(n){return n===1/0||Array.isArray(n)}function C(n,t=!0,e=!0){if((!n||!A(n))&&t)throw new Error(`Object must be of type object or array! "${X(n)}" given.`);return n instanceof O&&(n.type==="def"&&e?n=typeof n.value.get=="function"?n.value.get():n.value.value:n=n.value),n&&it(n)}function $e(n,t,e,r={}){return t===1/0?r.level&&!A(n)?e([]):e(Object.keys(n)):e(z(t,!1))}var ke={...Ft,...Et},y=ke;var It=(n,...t)=>{let e=t.pop();if(n.constructor.name==="AsyncFunction")return k(n.call(...t),e);try{return e(n.call(...t))}catch(r){return e(void 0,r)}},k=(n,t)=>n instanceof Promise?n.then(t).catch(e=>t(void 0,e)):t(n),Nt=n=>typeof n=="object"&&n||typeof n=="function";function Xt(n){let t=typeof n[n.length-1]=="object"?n.pop():{},e=n.pop()||"";return t.functionParams=n,{source:e,params:t}}var Yt={};function Zt(...n){let t,e={runtimeParams:je,compilerParams:Se,parserParams:Te};for(;t=n.shift();){let{runtimeParams:r={},compilerParams:{globalsNoObserve:i=[],globalsOnlyPathsExcept:o=[],...a}={},parserParams:s={}}=t;e={runtimeParams:{...e.runtimeParams,...r},compilerParams:{...e.compilerParams,globalsNoObserve:[...e.compilerParams.globalsNoObserve,...i],globalsOnlyPathsExcept:[...e.compilerParams.globalsOnlyPathsExcept,...o],...a},parserParams:{...e.parserParams,...s}},n.devMode}return e}var Te={ecmaVersion:"latest",allowReturnOutsideFunction:!0,allowAwaitOutsideFunction:!1,allowSuperOutsideMethod:!1,preserveParens:!1,locations:!0},Se={globalsNoObserve:["arguments","debugger"],globalsOnlyPathsExcept:[],originalSource:!0,locations:!0,compact:2},je={apiVersion:3};var ft=Object.create(null);var Q=class extends EventTarget{managedAlways=new Set;managedOnce=new Set;constructor(){super(),Yt.setMaxListeners?.(0,this)}fire(t){return this.dispatchEvent(new Event(t,{cancelable:!0}))}on(...t){return this.addEventListener(...t),()=>this.removeEventListener(...t)}abort(t=!1){this.managedAlways.forEach(e=>e.abort?e.abort(t):e(t)),this.managedOnce.forEach(e=>e.abort?e.abort(t):e(t)),this.managedOnce.clear(),this.fire("abort")}manage(t){this.managedAlways.add(t)}once(t){this.managedOnce.add(t)}};var K=class extends Q{subscribers=new Set;signals=new Map;constructor(t,e,r){super(),this.context=t,this.context?.once(()=>this.abort()),this.once(()=>this.watchMode(!1)),this.type=e,this.state=r}get name(){return[...this.context?.signals.keys()||[]].find(t=>this.context.signals.get(t)===this)}signal(t,e="prop"){let r=this.signals.get(t);return r||(r=new K(this,e,e==="object"?t:Nt(this.state)?y.get(this.state,t):void 0),this.signals.set(t,r),this.signals.size===1&&this.watchMode(),r.once(()=>{this.signals.delete(t),this.signals.size||this.watchMode(!1)})),r}subscribe(t){this.subscribers.add(t),t.once(()=>{this.subscribers.delete(t),this.subscribers.size||this.abort()})}watchMode(t=!0){this.mutationsWatch?.abort(),!(!t||!this.signals.size||!Nt(this.state))&&(this.mutationsWatch=y.observe(this.state,e=>{let r={map:new Map,add(o,a){for(let s of o)s.spec.beforeSchedule?.(a)!==!1&&(this.map.has(s.runtime)||this.map.set(s.runtime,new Set),this.map.get(s.runtime).add(s))}};for(let o of e){let a=this.signals.get(o.key);!a||(r.add(a.subscribers,o),a.refresh(o.value))}let i=r.map.size?[...r.map].sort((o,a)=>o.$serial>a.$serial?-1:1):r.map;for(let[o,a]of i)o.state!=="aborted"&&o.schedule(...a)},{recursions:"force-sync"}))}refresh(t){this.state=t;for(let[e,r]of this.signals)r.refresh(y.get(this.state??{},e));this.watchMode()}};var $=class extends K{symbols=new Map;constructor(t,e,r=void 0){super(t,e,r||Object.create(null))}};var R=class extends Q{state;constructor(t,e,r,i,o,a){super(),t?.once(this),this.context=t,this.type=e,this.spec=r||{},this.scope=o,t?.scope!==o&&this.manage(o),this.serial=i,a&&(this.closure=a),t?.type==="iteration"?this.path=t.path.concat(this.spec.index):t?.type==="round"?this.path=t.path.concat(this.serial):this.path=(t?.path||[]).slice(0,-1).concat(this.serial),this.flowControl=new Map}get runtime(){return this.context.runtime}contains(t){return this===t.context||t.context&&this.contains(t.context)}order(t){if(!t)return this;let[e,r]=t.path.length<this.path.length?[t,this]:[this,t];return e.path.reduce((i,o,a)=>i&&o<=r.path[a],!0)&&e||r}beforeExecute(){this.state="running";let t=this.flowControl;return this.flowControl=new Map,t}execute(t=null){return this.runtime.thread.unshift(this),k(this.beforeExecute(),e=>It(this.closure,this,this,(r,i)=>i?this.throw(i,[this.serial,this.context?.serial],i.code):(this.spec.complete&&(r=this.spec.complete(r,this)),this.afterExecute(e),this.runtime.thread.shift(),t?t(r,this):r)))}throw(t,e,r){if(this.type==="function"&&["HandlerFunction","FinalizerFunction"].includes(this.$params.executionMode))return this.$params.lexicalContext.throw(t,e,r);if(this.spec.handler)return this.spec.handler(t);if(this.type!=="function"&&this.context)return this.context.throw(t,e,r);if(t.cause)throw t;let i=`${t.message||t}`,o=r!==null?`[${r}]: ${i}`:i,a=e.map(c=>c!==-1&&this.extractSource(c,!0)).filter(c=>c);a.push({source:this.runtime.$params.originalSource});let s=globalThis[t.name],f=new(s||Error)(o,{cause:a}),u=this.runtime.$params.sourceType==="module"&&this.$params.experimentalFeatures!==!1&&this.$params.exportNamespace||this.$params.fileName;throw u&&(f.fileName=u),r&&(f.code=r),f}afterExecute(t){this.state="complete";let e=this.flowControl;this.spec.finalizer&&this.spec.finalizer(),this.handleDownstream(e.size,t.size),this.handleRightstream(e.size,t.size);for(let r of["break","continue","return"])e.has(r)&&!e.get(r).endpoint?this.hoistFlowControl(r,e.get(r).arg):t.has(r)&&!t.get(r).endpoint&&this.hoistFlowControl(r,t.get(r).arg,!0)}typed(t,e,r=void 0){let i=Array.isArray(e)?"array":e===null?"null":typeof e;if(i===t||t==="iterable"&&e?.[Symbol.iterator]||t==="desctructurable"&&!["undefined","null"].includes(i))return e;throw t==="iterable"?new Error("value is not iterable."):t==="desctructurable"?new Error((r?`Cannot access ${r}; `:"")+"object not desctructurable."):new Error(`value must be of type ${t}.`)}let(t,e,r,i={}){return this.var(t,e,r,{...i,kind:"let"})}const(t,e,r,i={}){return this.var(t,e,r,{...i,kind:"const"})}var(t,e,r,i={}){i={kind:"var",...i},r||(r=()=>{});let o=i.restOf?(...s)=>{try{return r(...s)}catch(f){throw new Error(`Cannot declare ${t}; ${f.message}`)}}:r,a=(s,f)=>{let u=f.scope;if(i.kind==="var")for(;!["module","function"].includes(u.type)&&!y.has(u.state,t)&&u.context;)u=u.context;else u.type==="this"&&u.context&&(u=u.context);let c=u.symbols.get(t);if(c&&(c.kind!==i.kind||i.kind==="let"&&c.serial!==e))throw new Error(`Identifier "${t}" has already been declared.`);c?.reader?.abort(),c={serial:e,kind:i.kind};let l=s;return i.restOf&&(i.type==="array"?l=[]:l={},c.reader=y.map(s,l,{except:i.restOf,spread:i.type==="array"}),f.once(c.reader)),u.symbols.set(t,c),y.set(u.state,t,l),l};return this.autorun(i.kind,{complete:a,...i},e,o)}update(t,e,r={}){let i=this.scope;for(;i&&!y.has(i.state,t);)i=i.context;if(!i)throw new ReferenceError(`${t} is not defined.`);let o=i.symbols.get(t);if(o?.kind==="const")throw new ReferenceError(`Assignment to constant variable "${t}".`);let a=y.get(i.state,t),s=r.restOf?(...f)=>{try{return e(...f)}catch(u){throw new Error(`Cannot update ${t}; ${u.message}`)}}:e;return It(s,void 0,a,(f,u)=>{if(u)return this.throw(u,[this.serial]);o?.reader?.abort();let c=f;return r.restOf&&(o=o||{},r.type==="array"?c=[]:c={},o.reader=y.map(f,c,{except:r.restOf,spread:r.type==="array"}),this.once(o.reader)),y.set(i.state,t,c),["postinc","postdec"].includes(r.kind)?a:c})}ref(t,...e){let r=0,i={};typeof e[0]=="number"?(r=e.shift(),i=e.shift()||{}):typeof e[0]=="object"&&(i=e.shift());let o=this.scope;for(;o&&!y.has(o.state,t);)o=o.context;if(!o){if(i.isTypeCheck)return;throw new Error(`${t} is not defined.`)}let a=o.symbols.get(t)?.kind,s=o.signal(t,a);return i.typed&&this.typed(i.typed,s.state,t),this.autobind(s,r,i)}obj(t,...e){let r=0,i={};return typeof e[0]=="number"?(r=e.shift(),i=e.shift()||{}):typeof e[0]=="object"&&(i=e.shift()),this.autobind(this.runtime.$objects.signal(t,"object"),r,i)}autobind(t,e,r){let i=["QuantumProgram","QuantumFunction"].includes(this.runtime.$params.executionMode),o=t.type==="const",a=this===this.runtime,s=this.state==="aborted",f=this.spec.static,u=this;return function c(l,m){if(i&&!f&&!o&&!a&&!s&&l.subscribe(u),!m||!l.state||typeof l.state!="object"){let p=l.state;return typeof l.state=="function"&&!/^class\s?/.test(Function.prototype.toString.call(l.state))&&(p=y.proxy(l.state,{membrane:l})),p}let x;return y.proxy(l.state,{},p=>({...p,get(w,b,g=null){return x?p.get(w,b,g):(x=!0,c(l.signal(b),m-1))}}))}(t,e)}autorun(t,...e){let r=e.pop(),i=e.pop(),o=e.pop()||{},a=R,s=this.scope;if(t==="iteration"){let u=this.runtime.constructor;a=r.constructor.name==="AsyncFunction"?u.AutoAsyncIterator:u.AutoIterator}["block","switch","iteration"].includes(t)&&(s=new $(s,t));let f=new a(this,t,o,i,s,r);if(t==="downstream"){if(this.downstream=f,this.flowControlApplied())return}else if(this.type==="switch"&&this.breakpoint)return;return f.execute()}function(t,e,r,i){e==="Declaration"&&y.set(this.scope.state,i.name,i);let o=this;return Object.defineProperty(i,"toString",{value:function(a=!1){if(a&&t==="QuantumFunction")return Function.prototype.toString.call(i);let s=o.runtime.extractSource(r);return s.startsWith("static ")?s.replace("static ",""):s}}),i}class(t,e,r){return t==="Declaration"&&y.set(this.scope.state,e.name,e),r.forEach(({name:i,isQuantumFunction:o,static:a,serial:s})=>{this.function(o&&"QuantumFunction"||"RegularFunction","Expression",s,a?e[i]:e.prototype[i])}),e}async import(...t){return this.runtime.import(...t)}async export(...t){return this.runtime.export(...t)}continue(t){return this.applyFlowControl("continue",t)}break(t){return this.applyFlowControl("break",t)}return(t){return this.applyFlowControl("return",t)}applyFlowControl(t,e,r=!1){let i=this.flowControl.size;if(r?this.flowControl.delete(t):this.flowControl.set(t,{arg:e}),this.type==="round"&&(this.context.breakpoint=this),this.type==="round"&&["break","continue"].includes(t)&&e===this.context?.spec.label){r||(this.flowControl.get(t).endpoint=!0),this.state!=="running"&&this.handleRightstream(this.flowControl.size,i);return}if(this.context?.type==="switch"&&t==="break"&&!e){r||(this.flowControl.get(t).endpoint=!0),this.context.breakpoint=this;return}this.state!=="running"&&(this.handleDownstream(this.flowControl.size,i),this.hoistFlowControl(...arguments))}hoistFlowControl(...t){return this.context?.applyFlowControl(...t)}flowControlApplied(t,e){return arguments.length?arguments.length===1?this.flowControl.has(t):this.flowControl.get(t)?.arg===e:this.flowControl.size||!1}handleDownstream(t,e){let r;!["block"].includes(this.type)||!(r=this.context?.downstream)||(t?r.abort():e&&(r.state="resuming",this.runtime.schedule(r)))}handleRightstream(t,e){if(this.type!=="round")return;let r=this,i=new Set;for(;r=r.nextRound;)t?r.abort():e&&r.state!=="inert"&&(r.state="resuming",i.add(r));i.size&&this.runtime.schedule(...i),!t&&e&&this.runtime.on("reflection",()=>{this.context.iterating||this.context.iterate()},{once:!0})}abort(t=!1){return t&&(this.context?.breakpoint===this&&delete this.context.breakpoint,this.flowControl.clear()),this.state=t?"inert":"aborted",super.abort(t)}};var G=class extends R{rounds=new Map;constructor(t,e,r,i,o,a){r.$closure=a,super(t,e,r,i,o),this.manage(()=>{delete this.breakpoint,this.rounds.clear()})}pseudorun(t){return this.runtime.iThread.unshift(this),k(t(),e=>(this.runtime.iThread.pop(),e))}createIterator(){return this.spec.kind==="for-in"?function*(){for(let t in this.iteratee)yield t}.call(this):this.spec.kind==="for-of"?function*(){for(let t of this.iteratee)yield t}.call(this):{next:()=>({done:!this.pseudorun(()=>this.spec.test(this))})}}closure(){["for-of","for-in"].includes(this.spec.kind)?([this.production,this.iteratee]=this.spec.parameters(this),this.iterator=this.createIterator(),this.iterator.original=!0,this.watchMode()):(this.spec.kind==="for"&&this.spec.init(this),this.iterator=this.createIterator()),this.iterate()}terminated(){return this.breakpoint&&!this.breakpoint.flowControlApplied("continue",this.spec.label)&&this.breakpoint.flowControlApplied()}advance(){this.spec.kind==="for"&&this.pseudorun(()=>this.spec.advance(this))}iterate(){this.iterating=!0;let t=()=>!this.terminated()&&!(this.cursor=this.iterator.next()).done,e=()=>{this.createRound(this.cursor.value).execute(),this.advance()};if(this.spec.kind==="do-while")do e();while(t());else for(;t();)e();this.iterating=!1}createRound(t){let e=this.rounds.size,r={index:e},i=["for-in","for-of"].includes(this.spec.kind)?{[this.production]:t}:{...this.scope.state},o=new $(this.scope,"round",i);this.scope.symbols.forEach((f,u)=>{o.symbols.set(u,f)});let a=new R(this,"round",r,this.serial,o,this.spec.$closure),s=this.spec.kind==="for-in"?t:e;return this.rounds.set(s,a),this.lastRound&&(this.lastRound.nextRound=a,a.prevRound=this.lastRound),this.lastRound=a,a}watchMode(){if(this.spec.static)return;let t=(e,r)=>{let i=new Set,o=new Set;for(let a of e){if(Array.isArray(this.iteratee)&&a.key==="length")continue;let s=this.spec.kind==="for-in"?a.key:a.value,f=this.spec.kind==="for-in"?a.key:parseInt(a.key),u=this.rounds.get(f);if(u)y.set(u.scope.state,this.production,s),a.type==="delete"&&(this.rounds.set(f,void 0),u.prevRound&&(u.prevRound.nextRound=u.nextRound),u.nextRound&&(u.nextRound.prevRound=u.prevRound),i.add(u));else if(a.type!=="delete"&&!a.isUpdate){if(this.spec.kind==="for-of"&&this.iterator.original&&!r.done)continue;o.add(s)}}this.runtime.on("reflection",()=>{i.forEach(a=>a.abort(!0))},{once:!0}),o.size&&(this.iterator=function*(a){yield*a,yield*o}(this.iterator),r.done&&this.iterate())};this.once(y.observe(this.iteratee,e=>{k(this.cursor,r=>t(e,r))}))}};var ct=class extends G{async createIterator(){return this.spec.kind==="for-in"?function*(){for(let t in this.iteratee)yield t}.call(this):this.spec.kind==="for-of"?function*(){for(let t of this.iteratee)yield t}.call(this):{next:async()=>({done:!await this.pseudorun(()=>this.spec.test(this))})}}async closure(){["for-of","for-in"].includes(this.spec.kind)?([this.production,this.iteratee]=await this.spec.parameters(this),this.iterator=await this.createIterator(),this.iterator.original=!0,this.watchMode()):(this.spec.kind==="for"&&await this.spec.init(this),this.iterator=await this.createIterator()),await this.iterate()}async iterate(){let t;this.iterating=!0;let e=async()=>!this.terminated()&&(this.cursor=this.iterator.next())&&(t=await this.cursor)&&!t.done,r=async()=>{await this.createRound(t.value).execute(),await this.advance()};if(this.spec.kind==="do-while")do await r();while(await e());else for(;await e();)await r();this.iterating=!1}};var H=class{constructor(t){Object.defineProperty(this,"runtime",{value:t});let e={statechange:()=>{y.defineProperty(this,"value",{value:t.flowControl.get("return")?.arg,enumerable:!0,configurable:!0})}};for(let r in e)t.on(r,e[r]),e[r]();t.$params.sourceType==="module"&&Object.defineProperty(this,"exports",{value:t.exports})}dispose(){return this.runtime.abort(!0)}};var J=class extends R{locations=[];queue=new Set;thread=[];iThread=[];constructor(t,e,r,i,o){let{$serial:a=0,spec:s,...f}=r;super(t,e,s,-1,i,o),this.$serial=a,this.$params=f,this.$objects=new $(void 0,"objects"),this.manage(this.$objects),this.exports=Object.create(null),this.$promises={imports:[],exports:[]},this.manage(()=>{y.deleteProperties(this.exports,Object.keys(this.exports)),this.$promises.imports.splice(0),this.$promises.exports.splice(0)})}extractSource(t,e=!1){let[[r,i,o],[a]]=this.locations[t],s=this.$params.originalSource.slice(r,a);return e?{expr:s,line:i,column:o}:s}get runtime(){return this}get nowRunning(){return this.thread[0]}schedule(...t){let e=this.queue.size;for(let r of t)this.queue.add(r);if(!e)return this.flowControlDirty=!1,function r(i,o){let a;for(let s of this.queue){if(o&&o.order(s)!==o||["aborted","running"].includes(s.state)||this.iThread[0]?.contains(s)){this.queue.delete(s);continue}a=a?a.order(s):s,o||(o=a)}return a?(a.abort(),a.execute(s=>(this.queue.delete(a),r.call(this,s,a)))):(this.fire("reflection"),this.flowControlApplied()&&this.fire("statechange"),i)}.call(this,void 0,this.nowRunning)}execute(t=null){return super.execute(e=>{let i=["QuantumProgram","QuantumFunction"].includes(this.$params.executionMode)?new H(this):this.flowControl.get("return")?.arg;return t?t(i,this):i})}spawn(t,e,r,i=null){let o=this.nowRunning||i||this,a={...this.$params,$serial:this.$serial+1,executionMode:t,lexicalContext:i},s=new $(o.scope,"function",{this:e});return new this.constructor(o,"function",a,s,r).execute()}async import(...t){let e=t.pop(),r=typeof e=="string"?{source:e}:e,i=a=>{if(r.forExport||r.isDynamic)return a;this.assignModules(t,this.scope.state,a,e.serial)};if(this.$params.experimentalFeatures!==!1&&ft[r.source])return i(ft[r.source]);let o=(async()=>{let a=this.$params.sourceType==="module"&&this.$params.experimentalFeatures!==!1&&this.$params.exportNamespace||this.$params.fileName;try{return i({...await import(r.source)})}catch(s){s.code==="ERR_MODULE_NOT_FOUND"?this.throw(new Error(`Cannot find module "${r.source}"${a?` imported at "${a}"`:""}.`),[r.serial],s.code):this.throw(s,[r.serial],s.code)}})();return r.isDynamic||this.$promises[r.forExport?"exports":"imports"].push(o),o}async export(...t){let e=Array.isArray(t[t.length-1])?null:t.pop(),r=e?await this.import({...e,forExport:!0}):this.scope.state;this.assignModules(t,this.exports,r,e?.serial)}assignModules(t,e,r,i=null){let o=[],a=["QuantumProgram","QuantumFunction"].includes(this.$params.executionMode);for(let[s,f,u]of t){if(s==="*"&&u){(a?y:Reflect).set(e,u,r);continue}y.has(r,s)||this.throw(new Error(`The requested module does not provide an export named "${s}".`),[f,i]),(a?y:Reflect).set(e,u||s,y.get(r,s)),o.push([s,f,u])}!o.length||!a||this.once(y.observe(r,s=>{for(let[f,,u]of o)for(let c of s)f==="*"?y.set(e,c.key,c.value):c.key===f&&y.set(e,u||f,c.value)}))}afterExecute(...t){return this.$params.sourceType==="module"&&this.$params.experimentalFeatures!==!1&&this.$params.exportNamespace&&(ft[this.$params.exportNamespace]=this.exports,this.once(()=>{delete ft[this.$params.exportNamespace]})),super.afterExecute(...t)}};N(J,"AutoAsyncIterator",ct),N(J,"AutoIterator",G);function xt(n,t,e,r){let{env:i,functionParams:o=[],exportNamespace:a,fileName:s}=r,{parserParams:f,compilerParams:u,runtimeParams:c}=Zt(r),l=Object.getOwnPropertyDescriptor(globalThis,"window")?.get?.toString().includes("[native code]")??!1,m=["async-script","module"].includes(n);if(n==="module")f.sourceType=n,f.allowAwaitOutsideFunction=!0;else if(["function","async-function"].includes(n)){let p="  "+e.split(`
`).join(`
  `);e=`return ${n==="async-function"?"async ":""}function**(${o.join(", ")}) {
${p}
}`,f.executionMode="RegularProgram"}else if(!["script","async-script"].includes(n))throw new Error(`Unrecognized sourceType specified: "${n}".`);u.sourceType=n,f.inBrowser=l,u.base64=m&&l&&"export default async function(%0) {%1}";let x=t(e,{parserParams:f,compilerParams:u});if(x instanceof Promise&&!["async-function","async-script","module"].includes(n))throw new Error("Parse-compile can only return a Promise for sourceTypes: async-function, async-script, module.");return c.sourceType=n,c.inBrowser=l,c.exportNamespace=a,c.fileName=s,k(x,p=>{let w=["function","async-function"].includes(n);return k(((g,d)=>{if(c.compileFunction)return c.compileFunction(d.toString(),[g]);if(u.base64){let h=`data:text/javascript;base64,${d.toString("base64")}`;return(()=>import(h).then(v=>v.default))()}return new(m?async function(){}.constructor:Function)(g,d.toString())})(p.identifier+"",p),g=>{let d=(h,E=i)=>{let v=g;h&&(v=v.bind(h));let I="global",L=new $(void 0,I,globalThis);return(n.endsWith("script")||E)&&(I="env",L=new $(L,I,E)),n==="module"&&(I="module",L=new $(L,I)),typeof h<"u"&&(L=new $(L,"this",{this:h})),new J(void 0,I,{...c,originalSource:p.originalSource,executionMode:p.isQuantumProgram&&"QuantumProgram"||"RegularProgram"},L,v)};return w?d().execute():{createRuntime:d,compilation:p}})})}var tt=class{constructor(...t){let e=this.constructor,r=typeof t[t.length-1]=="object"?t.pop():{},i=t.pop()||"";this.$program=xt(e.sourceType,e.parseCompileCallback,i,r)}execute(){return k(this.$program,({createRuntime:t})=>t().execute())}bind(t,e=void 0){return k(this.$program,({createRuntime:r})=>r(t,e))}toString(t=!1){return k(this.$program,({compilation:e})=>t?e+"":e.originalSource)}};var Ce;function te(...n){let{source:t,params:e}=Xt(n),r=xt("async-function",zt,t,e);if(!(r instanceof Promise))return r;let i=async function(...o){return(await r).call(this,...o)};return Object.defineProperty(i,"toString",{value:async function(...o){return(await r).toString(...o)}}),i}var Re=te,Me,et=class extends tt{};N(et,"sourceType","async-script"),N(et,"parseCompileCallback",zt);var qe=et,lt=class extends tt{};N(lt,"sourceType","module"),N(lt,"parseCompileCallback",zt);function zt(...n){let t=typeof n[n.length-1]=="object"?n.pop():{},e=n.pop()||"";if(globalThis.webqit?.$qCompiler){let{parse:r,compile:i}=globalThis.webqit.$qCompiler,o=r(e,t.parserParams);return i(o,t.compilerParams)}if(globalThis.webqit=globalThis.webqit||{},!globalThis.webqit.$qCompilerWorker){let o=`
        const compilerUrls = [ '${(document.querySelector('meta[name="$q-compiler-url"]')?.content.split(",")||[]).concat("https://unpkg.com/@webqit/quantum-js/dist/compiler.js").join("','")}' ];
        ( function importScript() {
            try { importScripts( compilerUrls.shift().trim() ) } catch( e ) { if ( compilerUrls.length ) { importScript(); } }
        } )();
        const { parse, compile } = globalThis.webqit.$qCompiler;
        globalThis.onmessage = e => {
            const { source, params } = e.data;
            const ast = parse( source, params.parserParams );
            const { toString, ...compilation } = compile( ast, params.compilerParams );
            e.ports[ 0 ]?.postMessage( compilation );
        };`;globalThis.webqit.$qCompilerWorker=new Worker(`data:text/javascript;base64,${btoa(o)}`)}return new Promise(r=>{let i=new MessageChannel;webqit.$qCompilerWorker.postMessage({source:e,params:t},[i.port2]),i.port1.onmessage=o=>{let{...a}=o.data;Object.defineProperty(a,"toString",{value:s=>s==="base64"?a.compiledSourceBase64:a.compiledSource}),r(a)}})}globalThis.webqit||(self.webqit={});Object.assign(globalThis.webqit,Lt);})();
//# sourceMappingURL=main.lite.js.map
