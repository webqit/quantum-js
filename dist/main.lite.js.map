{
  "version": 3,
  "sources": ["../src/index.lite.js", "../node_modules/@webqit/observer/src/main.js", "../node_modules/@webqit/util/js/isObject.js", "../node_modules/@webqit/util/js/getType.js", "../node_modules/@webqit/util/js/isArray.js", "../node_modules/@webqit/util/js/isTypeFunction.js", "../node_modules/@webqit/util/js/isNull.js", "../node_modules/@webqit/util/js/isUndefined.js", "../node_modules/@webqit/util/js/isTypeObject.js", "../node_modules/@webqit/util/js/isEmpty.js", "../node_modules/@webqit/util/js/isFunction.js", "../node_modules/@webqit/util/js/isString.js", "../node_modules/@webqit/util/js/isTypeArray.js", "../node_modules/@webqit/util/js/wq.js", "../node_modules/@webqit/util/arr/from.js", "../node_modules/@webqit/observer/src/util.js", "../node_modules/@webqit/observer/src/core/Registration.js", "../node_modules/@webqit/observer/src/core/ListenerRegistration.js", "../node_modules/@webqit/observer/src/core/Registry.js", "../node_modules/@webqit/observer/src/core/Descriptor.js", "../node_modules/@webqit/observer/src/core/ListenerRegistry.js", "../node_modules/@webqit/observer/src/core/TrapsRegistration.js", "../node_modules/@webqit/observer/src/core/TrapsRegistry.js", "../node_modules/@webqit/observer/src/actors.js", "../node_modules/@webqit/observer/src/index.js", "../src/util.js", "../src/params.js", "../src/runtime/hot-module-registry.js", "../src/runtime/EventTarget.js", "../src/runtime/Signal.js", "../src/runtime/Scope.js", "../src/runtime/Autorun.js", "../src/runtime/AutoIterator.js", "../src/runtime/AutoAsyncIterator.js", "../src/runtime/State.js", "../src/runtime/Runtime.js", "../src/runtime/index.js", "../src/AbstractQuantumScript.js", "../src/api.global.lite.js"],
  "sourcesContent": ["\n/**\n * @imports\n */\nimport Observer from '@webqit/observer';\nimport { _$functionArgs } from './util.js';\nimport { $eval } from './runtime/index.js';\nimport AbstractQuantumScript from './AbstractQuantumScript.js';\nimport State from './runtime/State.js';\n\n/** -------------- APIs */\n\nexport { Observer, State }\n\nexport let QuantumFunction;\n\nexport function AsyncQuantumFunction( ...args ) {\n    const { source, params } = _$functionArgs( args );\n    const compiledFunction = $eval( 'async-function', parseCompileCallback, source, params );\n    if ( !( compiledFunction instanceof Promise ) ) return compiledFunction;\n    // Introduce a wrapper function that awaits main function\n    const wrapperFunction = async function( ...args ) { return ( await compiledFunction ).call( this, ...args ); }\n    Object.defineProperty( wrapperFunction, 'toString', { value: async function( ...args ) { return ( await compiledFunction ).toString( ...args ) } } )\n    return wrapperFunction;\n}\nexport const QuantumAsyncFunction = AsyncQuantumFunction; // For backwards compat\n\nexport let QuantumScript;\n\nexport class AsyncQuantumScript extends AbstractQuantumScript {\n    static sourceType = 'async-script';\n    static parseCompileCallback = parseCompileCallback;\n}\nexport const QuantumAsyncScript = AsyncQuantumScript; // For backwards compat\n\n\nexport class QuantumModule extends AbstractQuantumScript {\n    static sourceType = 'module';\n    static parseCompileCallback = parseCompileCallback;\n}\n\n/** -------------- parse-compile */\n\nfunction parseCompileCallback( ...args ) {\n    const params = typeof args[ args.length - 1 ] === 'object' ? args.pop() : {};    \n    const source = args.pop() || '';\n    // $qCompiler has been loaded sync?\n    if ( globalThis.webqit?.$qCompiler ) {\n        const { parse, compile } = globalThis.webqit.$qCompiler;\n        const ast = parse( source, params.parserParams );\n        return compile( ast, params.compilerParams );\n    }\n    // Load and run $qCompiler async - in the background?\n    globalThis.webqit = globalThis.webqit || {};\n    if ( !globalThis.webqit.$qCompilerWorker ) {\n        const customUrl = document.querySelector( 'meta[name=\"$q-compiler-url\"]' );\n        const compilerUrls = ( customUrl?.content.split( ',' ) || [] ).concat( 'https://unpkg.com/@webqit/quantum-js/dist/compiler.js' );\n        const workerScriptText = `\n        const compilerUrls = [ '${ compilerUrls.join( `','` ) }' ];\n        ( function importScript() {\n            try { importScripts( compilerUrls.shift().trim() ) } catch( e ) { if ( compilerUrls.length ) { importScript(); } }\n        } )();\n        const { parse, compile } = globalThis.webqit.$qCompiler;\n        globalThis.onmessage = e => {\n            const { source, params } = e.data;\n            const ast = parse( source, params.parserParams );\n            const { toString, ...compilation } = compile( ast, params.compilerParams );\n            e.ports[ 0 ]?.postMessage( compilation );\n        };`;\n        globalThis.webqit.$qCompilerWorker = new Worker( `data:text/javascript;base64,${ btoa( workerScriptText ) }` );\n    }\n    return new Promise( res => {\n        let messageChannel = new MessageChannel;\n        webqit.$qCompilerWorker.postMessage( { source, params }, [ messageChannel.port2 ] );\n        messageChannel.port1.onmessage = e => {\n            const { ...compilation } = e.data;\n            Object.defineProperty( compilation, 'toString', {\n                value: base64 => base64 === 'base64' ? compilation.compiledSourceBase64 : compilation.compiledSource\n            } );\n            res( compilation );\n        }\n    } );\n}", "import { _isObject, _isTypeObject, _isFunction, _getType } from '@webqit/util/js/index.js';\nimport { _from as _arrFrom } from '@webqit/util/arr/index.js';\nimport { _wq, _await, env } from './util.js';\nimport ListenerRegistry from './core/ListenerRegistry.js';\nimport TrapsRegistry from './core/TrapsRegistry.js';\nimport Descriptor from './core/Descriptor.js';\nimport { unproxy } from './actors.js';\n\n/* ---------------SPECIAL APIs--------------- */\n\n/**\n * Creates a Path array instance from arguments.\n * \n * @param Array\t            ...segments\n *\n * @return Path\n */\nclass Path extends Array {}\nexport function path( ...segments ) {\n    return new Path( ...segments );\n}\n\n/**\n * Creates a \"Subtree\" directive.\n * \n * @return Subtree\n */\nclass Subtree extends Array {}\nexport function subtree() {\n    return new Subtree;\n}\n\n/**\n * Creates an \"Infinity\" directive.\n * \n * @return Infinity\n */\nexport function any() {\n    return Infinity;\n}\n\n/**\n * Reduces a path array against handler.\n * \n * @param Array|Object\t    target\n * @param Array\t            path\n * @param Function\t        receiver\n * @param Function\t        final\n * @param Object\t        params\n * \n * @example reduce( object, [ segement1, segement2 ], observe, ( value, flags ) => {}, params );\n *\n * @return Any\n */\nexport function reduce( target, path, receiver, final = x => x, params = {} ) {\n    const _isSubtree = path instanceof Subtree;\n    if ( !_isSubtree && !path?.length ) return;\n    return ( function eat( target, path, $params, $isSubtree ) {\n        const isSubtree = $isSubtree || path[ $params.level ] instanceof Subtree;\n        const segment = isSubtree ? Infinity : path[ $params.level ];\n        const isLastSegment = isSubtree ? false : $params.level === path.length - 1;\n        if ( target instanceof Descriptor && target.operation !== 'get' ) {\n            // Always probe event-generated trees\n            $params = { ...$params, probe: 'always' };\n        } else if ( $params.probe !== 'always' ) {\n            // Probe until (before) last segment\n            $params = { ...$params, probe: !isLastSegment };\n        }\n        // ---------------\n        return receiver( target, segment, ( result, ...args ) => {\n            // -----------\n            const addTrail = ( desc ) => {\n                if ( !( desc instanceof Descriptor ) ) return;\n                desc.path = 'key' in desc ? [ desc.key ] : [];\n                if ( target instanceof Descriptor ) {\n                    desc.path = 'key' in desc ? target.path.concat( desc.key ) : target.path.slice( 0 );\n                    Object.defineProperty( desc, 'context', { get: () => target, configurable: true } );\n                }\n            };\n            const flags = args[ 0 ] || {};\n            const advance = ( result ) => {\n                if ( result instanceof Descriptor && 'argumentsList' in result ) {\n                    return;\n                }\n                const $value = resolveObj( result/* a Descriptor who's value could be proxied */, false );\n                return _await( $value/* could be a promise */, $value => {\n                    if ( result instanceof Descriptor ) {\n                        result.value = $value; // Update to (fulfilled), unproxied, value\n                    } else {\n                        result = $value;\n                    }\n                    return eat( result, path, { ...$params, ...flags, keyInParent: result.key, level: $params.level + 1, }, isSubtree );\n                } );\n            };\n            // -----------\n            if ( isPropsList( segment ) && Array.isArray( result ) ) {\n                result.forEach( addTrail );\n                if ( isLastSegment ) {\n                    return final( result, ...args );\n                }\n                if ( isSubtree && result[ 0 ] instanceof Descriptor && ( result[ 0 ].operation !== 'get' || params.asGet ) ) {\n                    final( result, ...args );\n                }\n                for ( const entry of result ) {\n                    advance( entry );\n                }\n                return;\n            }\n            // -----------\n            addTrail( result );\n            if ( isLastSegment ) {\n                return final( result, ...args );\n            }\n            return advance( result );\n            // -----------\n        }, $params );\n    } )( target, path.slice( 0 ), { ...params, level: 0 }, _isSubtree );\n}\n\n/**\n * Adds an observer to a target's registry.\n *\n * @param Array|Object\t    target\n * @param String|Object\t    prop\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return AbortController\n */\nexport function observe( target, prop, receiver, params = {} ) {\n    // ---------------\n    const originalTarget = resolveObj( target, !params.level );\n\tif ( _isFunction( arguments[ 1 ] ) ) {\n        [ , receiver, params = {} ] = arguments;\n        prop = Infinity;\n\t}\n\tif ( !_isFunction( receiver ) ) throw new Error( `Handler must be a function; \"${ _getType( receiver ) }\" given!` );\n    if ( prop instanceof Path || prop instanceof Subtree ) return reduce( originalTarget, prop, observe, receiver, params );\n    // ---------------\n    params = { ...params, descripted: true };\n    delete params.live;\n    if ( !_isTypeObject( originalTarget ) ) return params.probe && get( originalTarget, prop, receiver, params ) || undefined;\n    // ---------------\n    const emit = bind( originalTarget, prop, receiver, params );\n    if ( params.probe ) {\n        return get( originalTarget, prop, emit, params );\n    }\n    return emit();\n}\n\n/**\n * Adds an interceptor object to a target's registry.\n *\n * @param Array|Object\t    target\n * @param Object\t        traps\n * @param Object\t\t    params\n *\n * @return AbortRegistry\n */\nexport function intercept( target, traps, params = {} ) {\n    // ---------------\n    const originalTarget = resolveObj( target );\n    if ( !_isObject( traps ) ) {\n        [ /*target*/, /*operation*/, /*handler*/, params = {} ] = arguments;\n        traps = { [ arguments[ 1 ] ]: arguments[ 2 ] };\n    }\n    // ---------------\n    return TrapsRegistry.getInstance( originalTarget, true, params.namespace ).addRegistration( { traps, params } );\n}\n\n/* ---------------QUERY APIs--------------- */\n\n/**\n * Performs a \"getOwnPropertyDescriptor\" operation.\n *\n * @param Array|Object\t    target\n * @param String|Number\t    prop\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function getOwnPropertyDescriptor( target, prop, receiver = x => x, params = {} ) {\n    return exec( target, 'getOwnPropertyDescriptor', { key: prop }, receiver, params );\n}\n\n/**\n * Performs a \"getOwnPropertyDescriptors\" operation.\n * @note this isn't part of the standard Reflect API.\n *\n * @param Array|Object\t    target\n * @param String|Number\t    prop\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function getOwnPropertyDescriptors( target, prop, receiver = x => x, params = {} ) {\n    return exec( target, 'getOwnPropertyDescriptors', { key: prop }, receiver, params );\n}\n\n/**\n * Performs a \"getPrototypeOf\" operation.\n *\n * @param Array|Object\t    target\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function getPrototypeOf( target, receiver = x => x, params = {} ) {\n    return exec( target, 'getPrototypeOf', {}, receiver, params );\n}\n\n/**\n * Performs a \"isExtensible\" operation.\n *\n * @param Array|Object\t    target\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function isExtensible( target, receiver = x => x, params = {} ) {\n    return exec( target, 'isExtensible', {}, receiver, params );\n}\n\n/**\n * Performs a \"ownKeys\" operation.\n *\n * @param Array|Object\t    target\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function ownKeys( target, receiver = x => x, params = {} ) {\n    return exec( target, 'ownKeys', {}, receiver, params );\n}\n\n/**\n * Performs an operation of the given \"type\".\n *\n * @param Array|Object\t    target\n * @param String|Number\t    prop\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function has( target, prop, receiver = x => x, params = {} ) {\n    return exec( target, 'has', { key: prop }, receiver, params );\n}\n\n/**\n * Performs a get operation.\n *\n * @param Array|Object\t    target\n * @param String|Number\t    prop\n * @param Function\t        receiver\n * @param Object\t        params\n *\n * @return Any\n */\nexport function get( target, prop, receiver = x => x, params = {} ) {\n    // ---------------\n    let isLive;\n    const originalTarget = resolveObj( target, !params.level );\n    if ( _isObject( receiver ) ) {\n        [ params, receiver ] = [ receiver, x => x ];\n    } else if ( params.live ) { isLive = true; }\n    if ( prop instanceof Path || prop instanceof Subtree ) return reduce( originalTarget, prop, get, receiver, { ...params, asGet: true } );\n    // ---------------\n    return resolveProps( originalTarget, prop, props => {\n        const related = [ ...props ];\n        return ( function next( results, _props, _done ) {\n            if ( !_props.length ) return _done( results );\n            const prop = _props.shift();\n            if ( ![ 'string', 'number', 'symbol' ].includes( typeof prop ) ) {\n                throw new Error( `Property name/key ${ prop } invalid.` );\n            }\n            // ---------\n            function defaultGet( descriptor, value = undefined ) {\n                const _next = value => ( descriptor.value = value, next( [ ...results, params.live || params.descripted ? descriptor : value ]/** not using concat() as value may be an array */, _props, _done ) );\n                if ( arguments.length > 1 ) return _next( value );\n                if ( !_isTypeObject( originalTarget ) ) return _next( originalTarget?.[ descriptor.key ] );\n                const accessorizedProps = _wq( originalTarget, 'accessorizedProps', false );\n                const accessorization = accessorizedProps && accessorizedProps.get( descriptor.key );\n                if ( accessorization && accessorization.intact() ) {\n                    return _next( accessorization.getValue( params.withPropertyDescriptors ) );\n                }\n                if ( params.withPropertyDescriptors ) {\n                    const desc = Object.getOwnPropertyDescriptor( originalTarget, descriptor.key );\n                    return _next( desc );\n                }\n                return _next( Reflect.get( originalTarget, descriptor.key/*, ...( params.receiver ? [ params.receiver ] : [] )*//*Throws Illegal invocation error ffor DOM nodes, e.g.*/ ) );\n            }\n            // ---------\n            const descriptor = new Descriptor( originalTarget, {\n                type: 'get',\n                key: prop,\n                value: undefined,\n                operation: 'get',\n                related,\n            } );\n            if ( !_isTypeObject( originalTarget ) ) return defaultGet( descriptor );\n            const trapsRegistry = TrapsRegistry.getInstance( originalTarget, false, params.namespace );\n            if ( trapsRegistry ) {\n                return trapsRegistry.emit( descriptor, defaultGet );\n            }\n            return defaultGet( descriptor );\n        } )( [], props.slice( 0 ), results => {\n            const result_s = isPropsList( prop/*original*/ ) ? results : results[ 0 ];\n            if ( isLive && _isTypeObject( originalTarget ) ) {\n                const emit = bind( originalTarget, prop, receiver, params, target.key );\n                return emit( result_s );\n            }\n            return receiver( result_s );\n        } );\n    }, params );\n}\n\n/* ---------------MUTATION APIs--------------- */\n\n/**\n * Performs a batch operation.\n * \n * @param Object\t        target\n * @param Function\t        callback\n * @param Object\t        params\n *\n * @return Void\n */\nexport function batch( target, callback, params = {} ) {\n    const originalTarget = resolveObj( target );\n    return ListenerRegistry.getInstance( originalTarget, true, params.namespace ).batch( callback, params );\n}\n\n/**\n * Performs a mirror operation.\n * \n * @param Object\t        source\n * @param Object\t        target\n * @param Object\t        params\n *\n * @return Void\n */\nexport function map( source, target, params = {} ) {\n    target = resolveObj( target );\n    source = resolveObj( source );\n    const only = ( params.only || [] ).slice( 0 ), except = ( params.except || [] ).slice( 0 );\n    const sourceKeys = Object.keys( params.spread ? [ ...source ] : source ).map( k => !isNaN( k ) ? parseInt( k ) : k );\n    const filteredKeys = only.length ? only.filter( k => sourceKeys.includes( k ) ) : sourceKeys.filter( k => !except.includes( k ) );\n    const resolveKey = k => { \n        if ( !Array.isArray( target ) || isNaN( k ) ) return k;\n        return k - except.filter( i => i < k ).length;\n    };\n    const doSet = key => {\n        const descriptor = getOwnPropertyDescriptor( source, key, params );\n        if ( ( 'value' in descriptor ) && descriptor.writable && descriptor.enumerable && descriptor.configurable ) {\n            set( target, resolveKey( key ), descriptor.value, params );\n        } else if ( descriptor.enumerable || params.onlyEnumerable === false ) { defineProperty( target, key, { ...descriptor, configurable: true }, params ); }\n    };\n    batch( target, () => {\n        filteredKeys.forEach( doSet );\n    } );\n    return observe( source, mutations => {\n        //batch( target, () => {\n            mutations.filter( m => only.length ? only.includes( m.key ) : !except.includes( m.key ) ).forEach( m => {\n                if ( m.type === 'delete' ) return deleteProperty( target, resolveKey( m.key ), params );\n                if ( m.type === 'def' ) {\n                    if ( m.value.enumerable || params.onlyEnumerable === false ) {\n                        defineProperty( target, resolveKey( m.key ), { ...m.value, configurable: true }, params );\n                    }\n                    return;\n                }\n                doSet( m.key );\n            } );\n        //}, params );\n    }, { ...params, withPropertyDescriptors: true } );\n}\n\n/**\n * Performs a set operation.\n * \n * @param Object\t        target\n * @param String|Number\t    prop\n * @param Any\t            value\n * @param Function\t        receiver\n * @param Object\t        params\n * @param Bool\t            def\n *\n * @return Any\n */\nexport function set( target, prop, value, receiver = x => x, params = {}, def = false ) {\n    // ---------------\n    const originalTarget = resolveObj( target );\n    let entries = [ [ prop, value ] ];\n    if ( _isObject( prop ) ) {\n        [ /*target*/, /*hash*/, receiver = x => x, params = {}, def = false ] = arguments;\n        entries = Object.entries( prop );\n    }\n    if ( _isObject( receiver ) ) { [ def, params, receiver ] = [ typeof params === 'boolean' ? params : def, receiver, x => x ]; }\n    // ---------------\n    const related = entries.map( ( [ prop ] ) => prop );\n    return ( function next( descriptors, entries, _done ) {\n        if ( !entries.length ) return _done( descriptors );\n        const [ prop, value ] = entries.shift();\n        // ---------\n        function defaultSet( descriptor, status = undefined ) {\n            const _next = status => ( descriptor.status = status, next( descriptors.concat( descriptor ), entries, _done ) );\n            if ( arguments.length > 1 ) return _next( descriptor, status );\n            const accessorizedProps = _wq( originalTarget, 'accessorizedProps', false );\n            const accessorization = accessorizedProps && accessorizedProps.get( descriptor.key );\n            if ( descriptor.type === 'def' ) {\n                if ( accessorization && !accessorization.restore() ) _next( false );\n                Object.defineProperty( originalTarget, descriptor.key, descriptor.value );\n                return _next( true );\n            }\n            if ( accessorization && accessorization.intact() ) {\n                return _next( accessorization.setValue( descriptor.value ) );\n            }\n            return _next( Reflect.set( originalTarget, descriptor.key, descriptor.value ) );\n        }\n        // ---------\n        function exec( isUpdate, oldValue ) {\n            if ( params.diff && value === oldValue ) return next( descriptors, entries, _done );\n            const descriptor = new Descriptor( originalTarget, {\n                type: def ? 'def' : 'set',\n                key: prop,\n                value,\n                isUpdate,\n                oldValue,\n                related: [ ...related ],\n                operation: def ? 'defineProperty' : 'set',\n                detail: params.detail,\n            } );\n            const trapsRegistry = TrapsRegistry.getInstance( originalTarget, false, params.namespace );\n            return trapsRegistry \n                ? trapsRegistry.emit( descriptor, defaultSet ) \n                : defaultSet( descriptor );\n        }\n        // ---------\n        return has( originalTarget, prop, exists => {\n            if ( !exists ) return exec( exists );\n            if ( prop === 'length' && Array.isArray( originalTarget ) && _wq( originalTarget ).has( '$length' ) ) {\n                return exec( true, _wq( originalTarget ).get( '$length' ) );\n            }\n            const $params = { ...params, withPropertyDescriptors: def };\n            return get( originalTarget, prop, oldValue => exec( exists, oldValue ), $params );\n        }, params );\n        // ---------\n    } )( [], entries.slice( 0 ), descriptors => {\n        const listenerRegistry = ListenerRegistry.getInstance( originalTarget, false, params.namespace );\n        if ( listenerRegistry ) listenerRegistry.emit( descriptors, { eventsArePropertyDescriptors: !!def } );\n        return receiver(\n            isPropsList( prop/*original*/ ) ? descriptors.map( opr => opr.status ) : descriptors[ 0 ]?.status\n        );\n    } );\n}\n\n/**\n * Performs a defineProperty operation.\n * \n * @param Object\t        target\n * @param String|Number\t    prop\n * @param Object\t        descriptor\n * @param Function\t        receiver\n * @param Object\t        params\n *\n * @return Any\n */\nexport function defineProperty( target, prop, descriptor, receiver = x => x, params = {} ) {\n    return set( target, prop, descriptor, receiver, params, true/*def*/ );\n}\n\n/**\n * Performs a defineProperties operation.\n * @note this isn't part of the standard Reflect API.\n * \n * @param Object\t        target\n * @param Object\t        descriptors\n * @param Function\t        receiver\n * @param Object\t        params\n *\n * @return Any\n */\nexport function defineProperties( target, descriptors, receiver = x => x, params = {} ) {\n    return set( target, descriptors, receiver, params, true/*def*/ );\n}\n\n/**\n * Performs a delete operation.\n * \n * @param Object\t        target\n * @param String|Number\t    prop\n * @param Function\t        receiver\n * @param Object\t        params\n *\n * @return Any\n */\nexport function deleteProperty( target, prop, receiver = x => x, params = {} ) {\n    // ---------------\n    const originalTarget = resolveObj( target );\n    if ( _isObject( receiver ) ) { [ params, receiver ] = [ receiver, x => x ]; }\n    // ---------------\n    const props = _arrFrom( prop, false ), related = [ ...props ];\n    return ( function next( descriptors, props, _done ) {\n        if ( !props.length ) return _done( descriptors );\n        const prop = props.shift();\n        // ---------\n        function defaultDel( descriptor, status = undefined ) {\n            const _next = status => ( descriptor.status = status, next( descriptors.concat( descriptor ), props, _done ) );\n            if ( arguments.length > 1 ) return _next( descriptor, status );\n            const accessorizedProps = _wq( originalTarget, 'accessorizedProps', false );\n            const accessorization = accessorizedProps && accessorizedProps.get( descriptor.key );\n            if ( accessorization && !accessorization.restore() ) _next( false );\n            return _next( Reflect.deleteProperty( originalTarget, descriptor.key ) );\n        }\n        // ---------\n        function exec( oldValue ) {\n            const descriptor = new Descriptor( originalTarget, {\n                type: 'delete',\n                key: prop,\n                oldValue,\n                related: [ ...related ],\n                operation: 'deleteProperty',\n                detail: params.detail,\n            } );\n            const trapsRegistry = TrapsRegistry.getInstance( originalTarget, false, params.namespace );\n            return trapsRegistry \n                ? trapsRegistry.emit( descriptor, defaultDel ) \n                : defaultDel( descriptor );\n        }\n        // ---------\n        return get( originalTarget, prop, exec, params );\n        // ---------\n    } )( [], props.slice( 0 ), descriptors => {\n        const listenerRegistry = ListenerRegistry.getInstance( originalTarget, false, params.namespace );\n        if ( listenerRegistry ) listenerRegistry.emit( descriptors );\n        return receiver(\n            isPropsList( prop/*original*/ ) ? descriptors.map( opr => opr.status ) : descriptors[ 0 ].status\n        );\n    } );\n}\n\n/**\n * @alias deleteProperty()\n */\nexport function deleteProperties( target, props, receiver = x => x, params = {} ) {\n    return deleteProperty( ...arguments );\n}\n\n/* ---------------EFFECT APIs--------------- */\n\n/**\n * Performs a \"construct\" operation.\n *\n * @param Array|Object\t    target\n * @param Array\t\t\t    argumentsList\n * @param Object\t\t    newTarget\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function construct( target, argumentsList, newTarget = null, receiver = x => x, params = {} ) {\n    return exec( target, 'construct', arguments.length > 2 ? { argumentsList, newTarget } : { argumentsList }, receiver, params );\n}\n\n/**\n * Performs an \"apply\" operation.\n *\n * @param Array|Object\t    target\n * @param Any\t            thisArgument\n * @param Array\t            argumentsList\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function apply( target, thisArgument, argumentsList, receiver = x => x, params = {} ) {\n    const originalThis = unproxy( thisArgument );\n    let returnValue;\n    if ( Array.isArray( thisArgument ) ) {\n        if ( params.arrayMethodName ) {\n            const descriptor = new Descriptor( originalThis, {\n                operation: params.arrayMethodName,\n                argumentsList\n            } );\n            const listenerRegistry = ListenerRegistry.getInstance( originalThis, false, params.namespace );\n            listenerRegistry?.emit( [ descriptor ], { eventIsArrayMethodDescriptor: true } );\n        }\n        _wq( originalThis ).set( '$length', originalThis.length );\n        returnValue = batch(\n            originalThis,\n            () => exec( target, 'apply', { thisArgument/*proxy wrappers allowed; in fact is why it works*/, argumentsList }, receiver, params ),\n            params\n        );\n        _wq( originalThis ).delete( '$length' );\n    } else {\n        returnValue = exec( target, 'apply', { thisArgument: originalThis, argumentsList }, receiver, params );\n    }\n    return returnValue;\n}\n\n/**\n * Performs a \"setPrototypeOf\" operation.\n *\n * @param Array|Object\t    target\n * @param Anyr\t            proto\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function setPrototypeOf( target, proto, receiver = x => x, params = {} ) {\n    return exec( target, 'setPrototypeOf', { proto }, receiver, params );\n}\n\n/**\n * Performs a \"preventExtension\" operation.\n *\n * @param Array|Object\t    target\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function preventExtensions( target, receiver = x => x, params = {} ) {\n    return exec( target, 'preventExtensions', {}, receiver, params );\n}\n\n/* ---------------HELPER APIs--------------- */\n\n/**\n * Adds an observer to a target's registry.\n *\n * @param Array|Object\t    target\n * @param String|Object\t    prop\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Function: AbortController\n */\nfunction bind( target, prop, receiver, params = {} ) {\n    const controller = new AbortController;\n    env.setMaxListeners?.( 0, controller.signal );\n    if ( params.signal ) { params.signal.addEventListener( 'abort', () => controller.abort() ); }\n    const $params = { ...params, signal: controller.signal };\n    const listenerRegistry = ListenerRegistry.getInstance( target, true, $params.namespace );\n    const childRegistrations = new Map;\n    return function emit( descriptor_s = [], prevRegistration = null ) {\n        let flags, registrationNext, isExisting;\n        if ( isPropsList( prop ) ) {\n            if ( prevRegistration ) {\n                isExisting = true;\n                registrationNext = prevRegistration;\n                for ( const descriptor of descriptor_s ) {\n                    childRegistrations.get( descriptor.key )?.remove();\n                    childRegistrations.delete( descriptor.key );\n                }\n            } else {\n                registrationNext = listenerRegistry.addRegistration( prop, emit, $params );\n            }\n            flags = { signal: registrationNext.signal, childRegistrations };\n        } else {\n            prevRegistration?.remove();\n            registrationNext = listenerRegistry.addRegistration( prop, emit, $params );\n            flags = { signal: registrationNext.signal };\n        }\n        // ------------------\n        if ( $params.childRegistrations && $params.keyInParent ) {\n            $params.childRegistrations.set( $params.keyInParent, registrationNext );\n        }\n        // ------------------\n        if ( arguments.length ) {\n            const handlerReturnValue = receiver( descriptor_s, flags );\n            if ( arguments.length > 1 ) return handlerReturnValue;\n        }\n        return controller;\n    };\n}\n\n/**\n * Performs an operation of the given \"type\".\n *\n * @param Array|Object\t    target\n * @param String\t\t    operation\n * @param Object\t\t    payload\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nfunction exec( target, operation, payload = {}, receiver = x => x, params = {} ) {\n    // ---------\n    target = resolveObj( target );\n    if ( _isObject( receiver ) ) { [ params, receiver ] = [ receiver, x => x ]; }    \n    // ---------\n    function defaultExec( descriptor, result ) {\n        if ( arguments.length > 1 ) return receiver( result );\n        return receiver( ( Reflect[ operation ] || Object[ operation ] )( target, ...Object.values( payload ) ) );\n    }\n    // ---------\n    const descriptor = new Descriptor( target, { operation, ...payload } );\n    const trapsRegistry = TrapsRegistry.getInstance( target, false, params.namespace );\n    if ( trapsRegistry ) {\n        return trapsRegistry.emit( descriptor, defaultExec );\n    }\n    return defaultExec( descriptor );\n}\n\n// Asks if prop is a multi-result field\nfunction isPropsList( prop ) {\n    return prop === Infinity || Array.isArray( prop );\n}\n\n// Resolves obj down to it's self\nfunction resolveObj( obj, assert = true, probePropertyDescriptors = true ) {\n\tif ( ( !obj || !_isTypeObject( obj ) ) && assert ) throw new Error( `Object must be of type object or array! \"${ _getType( obj ) }\" given.` );\n    if ( obj instanceof Descriptor ) {\n        if ( obj.type === 'def' && probePropertyDescriptors ) {\n            obj = typeof obj.value.get === 'function' ? obj.value.get() : obj.value.value;\n        } else {\n            obj = obj.value;\n        }\n    }\n\treturn obj && unproxy( obj );\n}\n\n// Resolves prop down to actual keys\nfunction resolveProps( obj, prop, receiver, params = {} ) {\n    if ( prop === Infinity ) {\n        if ( params.level && !_isTypeObject( obj ) ) return receiver( [] );\n        return receiver( Object.keys( obj ) );\n    }\n    return receiver( _arrFrom( prop, false ) );\n}\n", "\n/**\n * Tells if val is pure object.\n *\n * @param object\t \tval\n *\n * @return bool\n */\nexport default function(val) {\n\treturn !Array.isArray(val) && typeof val === 'object' && val;\n};\n", "\n/**\n * Returns the val's type.\n *\n * @param string \tval\n *\n * @return string\n */\nexport default function(val) {\n\treturn typeof val;\n};\n", "\n/**\n * Tells if val is of type \"array\".\n *\n * @param object\t \tval\n *\n * @return bool\n */\nexport default function(val) {\n\treturn Array.isArray(val);\n};\n", "\n/**\n * Tells if val is of type \"function\".\n * This holds true for both regular functions and classes.\n *\n * @param object\t \tval\n *\n * @return bool\n */\nexport default function(val) {\n\treturn typeof val === 'function';\n};\n", "\n/**\n * Tells if val is undefined or is null.\n *\n * @param string \tval\n *\n * @return bool\n */\nexport default function(val) {\n\treturn val === null || val === '';\n};\n", "\n/**\n * Tells if val is undefined or is of type \"undefined\".\n *\n * @param string \tval\n *\n * @return bool\n */\nexport default function(val) {\n\treturn arguments.length && (val === undefined || typeof val === 'undefined');\n};\n", "\n/**\n * @imports\n */\nimport _isTypeFunction from './isTypeFunction.js';\n\n/**\n * Tells if val is of type \"object\".\n * This holds true for anything object, including built-ins.\n *\n * @param object\t \tval\n *\n * @return bool\n */\nexport default function(val) {\n\treturn Array.isArray(val) || (typeof val === 'object' && val) || _isTypeFunction(val);\n};\n", "\n/**\n * @imports\n */\nimport _isNull from './isNull.js';\nimport _isUndefined from './isUndefined.js';\nimport _isTypeObject from './isTypeObject.js';\n\n/**\n * Tells if val is empty in its own type.\n * This holds true for NULLs, UNDEFINED, FALSE, 0,\n * objects without keys, empty arrays.\n *\n * @param string \tval\n *\n * @return bool\n */\nexport default function(val) {\n\treturn _isNull(val) || _isUndefined(val) || val === false || val === 0 \n\t\t|| (_isTypeObject(val) && !Object.keys(val).length);\n};\n", "\n/**\n * @imports\n */\nimport _isTypeFunction from './isTypeFunction.js';\n\n/**\n * Tells if val is of type \"function\".\n *\n * @param object \t\tval\n *\n * @return bool\n */\nexport default function(val) {\n\treturn _isTypeFunction(val) || (val && {}.toString.call(val) === '[object function]');\n};\n", "\n/**\n * Tells if val is of type \"string\".\n *\n * @param string \tval\n *\n * @return bool\n */\nexport default function(val) {\n\treturn val instanceof String || (typeof val === 'string' && val !== null);\n};\n", "\n/**\n * @imports\n */\nimport _isString from './isString.js';\nimport _isUndefined from './isUndefined.js';\n\n/**\n * Tells if val is \"array-like\".\n * This holds true for anything that has a length property.\n *\n * @param object\t \tval\n *\n * @return bool\n */\nexport default function(val) {\n\treturn !_isString(val) && !_isUndefined(val.length);\n};\n", "export default function wq(obj, ...namespaces) {\n    if (!obj || !['object', 'function'].includes(typeof obj)) {\n        throw new Error(`Argument #1 must be of type object`);\n    }\n    let wq = obj[Symbol.for('wq')];\n    if (!wq) {\n        wq = new WQInternals;\n        Object.defineProperty(obj, Symbol.for('wq'), {\n            value: wq,\n            // Defaults, but to be explicit...\n            enumerable: false,\n            configurable: false,\n            writable: false\n        });\n    }\n    if (!namespaces.length) {\n        return wq;\n    }\n    let _ns, _wq;\n    while ((_ns = namespaces.shift())) {\n        if ((_wq = wq) && !(wq = wq.get(_ns))) {\n            wq = new WQInternals;\n            _wq.set(_ns, wq);\n        }\n    }\n    return wq;\n}\n\nclass WQInternals extends Map {}", "\n/**\n * @imports\n */\nimport _isArray from '../js/isArray.js';\nimport _isTypeArray from '../js/isTypeArray.js';\nimport _isEmpty from '../js/isEmpty.js';\nimport _isObject from '../js/isObject.js';\n\n/**\n * Casts an array-like object to an array.\n *\n * @param mixed \tval\n * @param bool\t \tcastObject\n *\n * @return array\n */\nexport default function(val, castObject = true) {\n\tif (_isArray(val)) {\n\t\treturn val;\n\t};\n\tif (!castObject && _isObject(val)) {\n\t\treturn [val];\n\t};\n\tif (val !== false && val !== 0 && _isEmpty(val)) {\n\t\treturn [];\n\t};\n\tif (_isTypeArray(val)) {\n\t\treturn Array.prototype.slice.call(val);\n\t};\n\tif (_isObject(val)) {\n\t\treturn Object.values(val);\n\t};\n\treturn [val];\n};\n", "\n/**\n * @imports\n */\nimport { _wq as __wq } from '@webqit/util/js/index.js';\n\nexport const _wq = ( target, ...args ) => __wq( target, 'observerAPI', ...args );\n\nexport const _await = ( value, callback ) => value instanceof Promise ? value.then( callback ) : callback( value );\n\nexport const env = {};\n", "\n/**\n * ---------------------------\n * The Registration class\n * ---------------------------\n */\n\nexport default class Registration {\n\t\n\t/**\n\t * Initializes the instance.\n\t *\n\t * @param Registry\t\t\tregistry\n\t * @param object\t\t\tdfn\n\t *\n\t * @return void\n\t */\n\tconstructor( registry, dfn ) {\n\t\tthis.registry = registry;\n\t\tObject.assign( this, { ...dfn, target: registry.target } );\n\t\tif ( this.params.signal ) {\n\t\t\tthis.params.signal.addEventListener( 'abort', () => this.remove() );\n\t\t}\n\t}\n\n\t/**\n\t * Sets a \"disconnected\" flag on the Registration.\n\t *\n\t * @return void\n\t */\n\tremove() {\n\t\tthis.removed = true;\n\t\treturn this.registry.removeRegistration( this );\n\t}\n}", "\n/**\n * @imports\n */\nimport { _from as _arrFrom } from '@webqit/util/arr/index.js';\nimport Registration from './Registration.js';\nimport { _await, env } from '../util.js';\n\n/**\n * ---------------------------\n * The ListenerRegistration class\n * ---------------------------\n */\n\nexport default class ListenerRegistration extends Registration {\n\t\n\t/**\n\t * @constructor\n\t */\n\tconstructor() {\n\t\tsuper( ...arguments );\n\t\tthis.emit.currentRegistration = this;\n\t\tObject.defineProperty( this, 'abortController', { value: new AbortController } );\n\t\tObject.defineProperty( this, 'signal', { value: this.abortController.signal } );\n\t\tenv.setMaxListeners?.( 0, this.signal );\n\t}\n\n\t/**\n\t * De-registers the instance.\n\t * \n\t * @return Void\n\t */\n\tremove() {\n\t\tthis.abortController.abort();\n\t\tsuper.remove();\n\t}\n\n\t/**\n\t * Calls the observer's handler function\n\t * on matching with the event's fields.\n\t *\n\t * @param Array\t\t\t \t\tevents\n\t *\n\t * @return Any\n\t */\n\tfire( events ) {\n\t\tif ( this.emit.recursionTarget && ![ 'inject', 'force-async', 'force-sync' ].includes( this.params.recursions ) ) return;\n\t\tlet matches = events, filter = this.filter;\n\t\tif ( filter !== Infinity && ( filter = _arrFrom( filter, false ) ) ) {\n\t\t\tmatches = events.filter( event => filter.includes( event.key ) );\n\t\t}\n\t\tif ( this.params.diff ) {\n\t\t\tmatches = matches.filter( event => event.type !== 'set' || event.value !== event.oldValue );\n\t\t}\n\t\tif ( !matches.length ) return;\n\t\tif ( [ 'inject', 'defer' ].includes( this.params.recursions ) ) {\n\t\t\tif ( this.emit.recursionTarget ) {\n\t\t\t\tthis.emit.recursionTarget.push( ...matches );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.emit.recursionTarget = this.params.recursions === 'inject' ? matches : [];\n\t\t}\n\t\tconst $ret = this.filter === Infinity || Array.isArray( this.filter )\n\t\t\t? this.emit( matches, this )\n\t\t\t: this.emit( matches[ 0 ], this );\n\t\t// NOTEL: on calling emit(), this registration has expired and a new one active!!!\n\t\treturn _await( $ret, ret => {\n\t\t\tconst recursions = this.emit.recursionTarget;\n\t\t\tdelete this.emit.recursionTarget;\n\t\t\tif ( this.params.recursions === 'defer' ) {\n\t\t\t\tif ( recursions?.length ) return this.emit.currentRegistration.fire( recursions );\n\t\t\t}\n\t\t\treturn ret;\n\t\t} );\n\t}\n}\n", "\n/**\n * @imports\n */\nimport { _isTypeObject, _getType } from '@webqit/util/js/index.js';\nimport { _from as _arrFrom, _intersect, _equals as _arrEquals } from '@webqit/util/arr/index.js';\nimport { _wq } from '../util.js';\n\n/**\n * ---------------------------\n * The Registry class\n * ---------------------------\n */\n\nexport default class Registry {\n\t\n\t/**\n\t * Initializes the instance.\n\t *\n\t * @param object\ttarget\n\t * \n\t * @return void\n\t */\n\tconstructor( target ) {\n\t\tthis.target = target;\n\t\tthis.entries = [];\n\t}\n\t\n\t/**\n\t * Adds an Registration instance\n\t * with optional tags.\n\t *\n\t * @param Registration\t\tregistration\n\t *\n\t * @return Registration\n\t */\n\taddRegistration( registration ) {\n\t\tthis.entries.push( registration );\n\t\treturn registration;\n\t}\n\t\n\t/**\n\t * Removes registrations by reference.\n\t *\n\t * @param Registration\t\tregistration\n\t *\n\t * @return void\n\t */\n\tremoveRegistration( registration ) {\n\t\tthis.entries = this.entries.filter( _entry => _entry !== registration );\n\t}\n\t\t\n\t/**\n\t * Returns a observer-specific object embedded on an element.\n\t *\n\t * @param string\t\ttype\n\t * @param array|object\ttarget\n\t * @param bool      \tcreateIfNotExists\n\t * @param string      \tnamespace\n\t *\n\t * @return Registry\n\t */\n\tstatic _getInstance( type, target, createIfNotExists = true, namespace = this.__namespace ) {\n\t\tif ( !_isTypeObject( target ) ) throw new Error( `Subject must be of type object; \"${ _getType( target ) }\" given!` );\n\t\tlet ImplementationClass = this;\n\t\tif ( namespace && _wq( Registry, 'namespaces' ).has( type + '-' + namespace ) ) {\n\t\t\tImplementationClass = _wq( Registry, 'namespaces' ).get( type + '-' + namespace );\n\t\t\ttype += '-' + namespace\n\t\t}\n\t\tif ( !_wq( target, 'registry' ).has( type ) && createIfNotExists ) {\n\t\t\t_wq( target, 'registry' ).set( type, new ImplementationClass( target ) );\n\t\t}\n\t\treturn _wq( target, 'registry' ).get( type );\n\t}\n\n\t/**\n\t * Extend a Fireable Class with a namespace.\n\t *\n\t * @param string\t\tnamespace\n\t * @param class      \tImplementationClass\n\t *\n\t * @return void|class\n\t */\n\tstatic _namespace( type, namespace, ImplementationClass = null ) {\n\t\ttype += '-' + namespace;\n\t\tif ( arguments.length === 2 ) return _wq( Registry, 'namespaces' ).get( type );\n\t\tif ( !( ImplementationClass.prototype instanceof this ) ) {\n\t\t\tthrow new Error( `The implementation of the namespace ${ this.name }.${ namespace } must be a subclass of ${ this.name }.` );\n\t\t}\n\t\t_wq( Registry, 'namespaces' ).set( type, ImplementationClass );\n\t\tImplementationClass.__namespace = namespace;\n\t}\n}", "\n/**\n * ---------------------------\n * The Descriptor class\n * ---------------------------\n */\n\nexport default class Descriptor {\n\t\n\t/**\n\t * Initializes the instance.\n\t *\n\t * @param array|object\ttarget\n\t * @param object\t\tdfn\n\t *\n\t * @return void\n\t */\n\tconstructor( target, dfn ) {\n\t\tthis.target = target;\n\t\tif ( !( dfn.operation ) ) throw new Error( 'Descriptor operation must be given in definition!' );\n\t\tObject.assign( this, dfn );\n\t}\n}", "\n/**\n * @imports\n */\nimport ListenerRegistration from './ListenerRegistration.js';\nimport Registry from './Registry.js';\nimport { _await } from '../util.js';\nimport Descriptor from './Descriptor.js';\n\n/**\n * ---------------------------\n * The ListenerRegistry class\n * ---------------------------\n */\n\nexport default class ListenerRegistry extends Registry {\n\n\tstatic getInstance( target, createIfNotExists = true, namespace = null ) {\n\t\treturn super._getInstance( 'listeners', ...arguments );\n\t}\n\n\tstatic namespace( namespace, ImplementationClass = null ) {\n\t\treturn super._namespace( 'listeners', ...arguments );\n\t}\n\n\t/**\n\t * @constructor\n\t */\n\tconstructor( target ) {\n\t\tsuper( target );\n\t\tthis.batches = [];\n\t}\n\t\n\t/**\n\t * @addRegistration\n\t */\n\taddRegistration( filter, emit, params ) {\n\t\treturn super.addRegistration( new ListenerRegistration( this, { filter, emit, params } ) );\n\t}\n\t\n\t/**\n\t * Fires all observers with the given evt (change).\n\t *\n\t * @param Arrayn events\n\t *\n\t * @return Void\n\t */\n\temit( events, { eventsArePropertyDescriptors = false, eventIsArrayMethodDescriptor = false } = {} ) {\n\t\tif ( this.batches.length ) {\n\t\t\tconst arrayMethodName = this.batches[ 0 ].params.arrayMethodName;\n\t\t\tthis.batches[ 0 ].snapshots.push( {\n\t\t\t\tevents: [ ...events ],\n\t\t\t\tarrayMethodName, // Typically from array operations\n\t\t\t\teventsArePropertyDescriptors, // Typically from defineProperty() operations\n\t\t\t\teventIsArrayMethodDescriptor // Typically from array method operations\n\t\t\t} );\n\t\t\treturn\n\t\t}\n\t\tthis.$emit( this.entries, [ {\n\t\t\tevents, \n\t\t\teventsArePropertyDescriptors, // Typically from defineProperty() operations\n\t\t\teventIsArrayMethodDescriptor // Typically from array method operations\n\t\t} ] );\n\t}\n\n\t$emit( listeners, snapshots ) {\n\t\t// Analyse listener modes\n\t\tlet listenersLength = 0,\n\t\tlistenersAskingEventsWithPropertyDescriptors = 0,\n\t\tlistenersAskingArrayMethodDescriptors = 0;\n\t\tfor ( const listener of listeners ) {\n\t\t\tlistenersLength += 1;\n\t\t\tif ( listener.params.withPropertyDescriptors ) {\n\t\t\t\tlistenersAskingEventsWithPropertyDescriptors += 1;\n\t\t\t}\n\t\t\tif ( listener.params.withArrayMethodDescriptors ) {\n\t\t\t\tlistenersAskingArrayMethodDescriptors += 1;\n\t\t\t}\n\t\t}\n\t\t// Sort events\n\t\tconst events_with_PropertyDescriptors_with_ArrayMethodDescriptors = [], events_with_PropertyDescriptors_without_ArrayMethodDescriptors = [];\n\t\tconst events_without_PropertyDescriptors_with_ArrayMethodDescriptors = [], events_without_PropertyDescriptors_without_ArrayMethodDescriptors = [];\n\t\tfor ( const snapshot of snapshots ) {\n\t\t\tconst arrayMethodName = snapshot.arrayMethodName;\n\t\t\tconst eventsArePropertyDescriptors = snapshot.eventsArePropertyDescriptors;\n\t\t\tconst eventIsArrayMethodDescriptor = snapshot.eventIsArrayMethodDescriptor;\n\t\t\tfor ( const event of snapshot.events ) {\n\t\t\t\tif ( arrayMethodName ) {\n\t\t\t\t\tevent.operation = arrayMethodName;\n\t\t\t\t}\n\t\t\t\t// Some opting in to PropertyDescriptors\n\t\t\t\tif ( listenersAskingEventsWithPropertyDescriptors ) {\n\t\t\t\t\t//if ( !arrayMethodName ) { }\n\t\t\t\t\tlistenersAskingArrayMethodDescriptors && // Some opting in to ArrayMethodDescriptors\n\t\t\t\t\tevents_with_PropertyDescriptors_with_ArrayMethodDescriptors.push( event );\n\t\t\t\t\tif ( !eventIsArrayMethodDescriptor ) {\n\t\t\t\t\t\tlistenersAskingArrayMethodDescriptors !== listenersLength && // Some opting out of ArrayMethodDescriptors\n\t\t\t\t\t\tevents_with_PropertyDescriptors_without_ArrayMethodDescriptors.push( event );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Some opting out of PropertyDescriptors\n\t\t\t\tif ( listenersAskingEventsWithPropertyDescriptors !== listenersLength ) {\n\t\t\t\t\tlet $event = event;\n\t\t\t\t\tif ( eventsArePropertyDescriptors ) {\n\t\t\t\t\t\tconst { target, type, ...details } = event;\n\t\t\t\t\t\t$event = new Descriptor( target, { type: 'set', ...details } );\n\t\t\t\t\t\tObject.defineProperty( $event, 'value', 'get' in details.value ? { get: () => details.value.get() } : { value: details.value.value } )\n\t\t\t\t\t\tif ( details.oldValue ) {\n\t\t\t\t\t\t\tObject.defineProperty( $event, 'oldValue', 'get' in details.oldValue ? { get: () => details.oldValue.get() } : { value: details.oldValue.value } )\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//if ( !arrayMethodName/*Although eedless as is typically mutually exclusive to eventsArePropertyDescriptors*/ ) { }\n\t\t\t\t\tlistenersAskingArrayMethodDescriptors && // Some opting in to ArrayMethodDescriptors\n\t\t\t\t\tevents_without_PropertyDescriptors_with_ArrayMethodDescriptors.push( $event );\n\t\t\t\t\tif ( !eventIsArrayMethodDescriptor ) { // Although eedless as is typically already implied by eventsArePropertyDescriptors\n\t\t\t\t\t\tlistenersAskingArrayMethodDescriptors !== listenersLength && // Some opting out of ArrayMethodDescriptors\n\t\t\t\t\t\tevents_without_PropertyDescriptors_without_ArrayMethodDescriptors.push( $event );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Dispatch\n\t\tfor ( const listener of listeners ) {\n\t\t\tif ( listener.params.withPropertyDescriptors ) {\n\t\t\t\tif ( listener.params.withArrayMethodDescriptors ) {\n\t\t\t\t\tevents_with_PropertyDescriptors_with_ArrayMethodDescriptors.length &&\n\t\t\t\t\tlistener.fire( events_with_PropertyDescriptors_with_ArrayMethodDescriptors );\n\t\t\t\t} else {\n\t\t\t\t\tevents_with_PropertyDescriptors_without_ArrayMethodDescriptors.length &&\n\t\t\t\t\tlistener.fire( events_with_PropertyDescriptors_without_ArrayMethodDescriptors );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ( listener.params.withArrayMethodDescriptors ) {\n\t\t\t\t\tevents_without_PropertyDescriptors_with_ArrayMethodDescriptors.length &&\n\t\t\t\t\tlistener.fire( events_without_PropertyDescriptors_with_ArrayMethodDescriptors );\n\t\t\t\t} else {\n\t\t\t\t\tevents_without_PropertyDescriptors_without_ArrayMethodDescriptors.length &&\n\t\t\t\t\tlistener.fire( events_without_PropertyDescriptors_without_ArrayMethodDescriptors );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Fires all observers with the given evt (change).\n\t *\n\t * @param Arrayn events\n\t *\n\t * @return Void\n\t */\n\tbatch( callback, params = {} ) {\n\t\tthis.batches.unshift( { entries: [ ...this.entries ], snapshots: [], params } );\n\t\tconst returnValue = callback();\n\t\treturn _await( returnValue, returnValue => {\n\t\t\tconst batch = this.batches.shift();\n\t\t\tif ( !batch.snapshots.length ) return returnValue;\n\t\t\tthis.$emit( batch.entries, batch.snapshots );\n\t\t\treturn returnValue;\n\t\t} );\n\t}\n\n}\n", "\n/**\n * @imports\n */\nimport Registration from './Registration.js';\n\n/**\n * ---------------------------\n * The TrapsRegistration class\n * ---------------------------\n */\n\nexport default class TrapsRegistration extends Registration {\n\t\n\t/**\n\t * Calls the observer's handler function\n\t * on matching with the descriptor's fields.\n\t *\n\t * @param Descriptor\t\t\t \tdescriptor\n\t * @param function\t\t\t\t\tnext\n\t * @param mixed\t\t\t\t\t \trecieved\n\t *\n\t * @return void\n\t */\n\texec( descriptor, next, recieved ) {\n\t\tif ( this.running || !this.traps[ descriptor.operation ] ) {\n\t\t\treturn next( ...Array.prototype.slice.call( arguments, 2 ) );\n\t\t}\n\t\tthis.running = true;\n\t\treturn this.traps[ descriptor.operation ]( descriptor, recieved, ( ...args ) => {\n\t\t\tthis.running = false;\n\t\t\treturn next( ...args );\n\t\t} );\n\t}\n}", "\n/**\n * @imports\n */\nimport TrapsRegistration from './TrapsRegistration.js';\nimport Registry from './Registry.js';\n\n/**\n * ---------------------------\n * The TrapsRegistry class\n * ---------------------------\n */\n\nexport default class TrapsRegistry extends Registry {\n\n\tstatic getInstance( target, createIfNotExists = true, namespace = null ) {\n\t\treturn super._getInstance( 'traps', ...arguments );\n\t}\n\n\tstatic namespace( namespace, ImplementationClass = null ) {\n\t\treturn super._namespace( 'traps', ...arguments );\n\t}\n\t\n\t/**\n\t * @inheritdoc\n\t */\n\taddRegistration( dfn ) {\n\t\treturn super.addRegistration( new TrapsRegistration( this, dfn ) );\n\t}\n\n\t/**\n\t * Fires all interceptors with the given action.\n\t *\n\t * @param Descriptor\t\tdescriptor\n\t * @param function\t\t\tdefaultHandler\n\t *\n\t * @return mixed\n\t */\n\temit( descriptor, defaultHandler = null ) {\n\t\tconst $this = this;\n\t\treturn ( function next( index, ..._args ) {\n\t\t\tconst registration = $this.entries[ index ];\n\t\t\tif ( registration ) {\n\t\t\t\treturn registration.exec( descriptor, ( ...args ) => {\n\t\t\t\t\treturn next( index + 1, ...args );\n\t\t\t\t}/*next*/, ..._args );\n\t\t\t}\n\t\t\treturn defaultHandler ? defaultHandler( descriptor, ..._args ) : _args[ 0 ];\n\t\t} )( 0 );\n\t}\n}", "\n/**\n * @imports\n */\nimport { _from as _arrFrom } from '@webqit/util/arr/index.js';\nimport { _isClass, _isFunction, _isTypeObject, _getType } from '@webqit/util/js/index.js';\nimport { set, deleteProperty, has, get, ownKeys, defineProperty, getOwnPropertyDescriptor } from \"./main.js\";\nimport { apply, construct, getPrototypeOf, setPrototypeOf, isExtensible, preventExtensions } from \"./main.js\";\nimport { _wq } from './util.js';\n\n/* ---------------ACCESSORIZE METHODS--------------- */\n\n/**\n * Accessorizes props.\n *\n * @param Array|Object\ttarget\n * @param String|Array\tprops\n * @param Object\t\tparams\n *\n * @return Array\n */\nconst symWQOriginal = Symbol('wqOriginal');\nexport function accessorize( target, props, params = {} ) {\n    target = resolveTarget( target );\n    const accessorizedProps = _wq( target, 'accessorizedProps' );\n    // ---------\n    function getDescriptorDeep( prop ) {\n        let descriptor, proto = target;\n        do {\n            descriptor = Object.getOwnPropertyDescriptor( proto, prop );\n        } while ( !descriptor && ( proto = Object.getPrototypeOf( proto ) ) );\n        return descriptor \n            ? { proto, descriptor } \n            : { descriptor: { value: undefined, configurable: true, enumerable: true, writable: true } };\n    }\n    // ---------\n    function accessorizeProp( prop ) {\n        if ( accessorizedProps.has( prop + '' ) ) return true;\n        // ------------------\n        // Current Descriptor Record\n        const currentDescriptorRecord = getDescriptorDeep( prop );\n        currentDescriptorRecord.getValue = function( withPropertyDescriptors = false ) {\n            if ( withPropertyDescriptors ) return this.descriptor;\n            return this.descriptor.get ? this.descriptor.get() : this.descriptor.value;\n        };\n        currentDescriptorRecord.setValue = function( value, withPropertyDescriptors = false ) {\n            this.dirty = true;\n            if ( withPropertyDescriptors ) { this.descriptor = value; return; }\n            return this.descriptor.set ? this.descriptor.set( value ) !== false : ( this.descriptor.value = value, true );\n        };\n        currentDescriptorRecord.intact = function() {\n            const currentDescriptor = Object.getOwnPropertyDescriptor( target, prop );\n            return currentDescriptor?.get === accessorization.get \n                && currentDescriptor?.set === accessorization.set\n                && accessorizedProps.get( prop + '' ) === this;\n        };\n        currentDescriptorRecord.restore = function() {\n            if ( !this.intact() ) return false;\n            if ( ( this.proto && this.proto !== target ) || ( !this.proto && !this.dirty ) ) { delete target[ prop ]; }\n            else { Object.defineProperty( target, prop, this.descriptor ); }\n            accessorizedProps.delete( prop + '' );\n            return true;\n        };\n        accessorizedProps.set( !isNaN( prop ) ? parseInt( prop ) : prop, currentDescriptorRecord );\n        // ------------------\n        // enumerable, configurable\n        const { enumerable = true } = currentDescriptorRecord.descriptor;\n        const accessorization = { enumerable, configurable: true };\n        // set, get\n        if ( ( 'value' in currentDescriptorRecord.descriptor ) || currentDescriptorRecord.descriptor.set ) {\n            accessorization.set = function ( value ) { return set( this, prop, value, params ); };\n        }\n        if ( ( 'value' in currentDescriptorRecord.descriptor ) || currentDescriptorRecord.descriptor.get ) {\n            accessorization.get = function () { return get( this, prop, params ); };\n        }\n        try {\n            Object.defineProperty( target, prop, accessorization );\n            return true;\n        } catch( e ) {\n            accessorizedProps.delete( prop + '' );\n            return false;\n        }\n    }\n    const _props = Array.isArray( props ) ? props : (\n        props === undefined ? Object.keys( target ) : [ props ]\n    );\n    const statuses = _props.map( accessorizeProp );\n    return props === undefined || Array.isArray( props ) \n        ? statuses \n        : statuses[ 0 ];\n}\n\n/**\n * Unaccessorizes previously accessorized props.\n *\n * @param Array|Object\ttarget\n * @param String|Array\tprops\n * @param Object\t\tparams\n *\n * @return Array\n */\nexport function unaccessorize( target, props, params = {} ) {\n    target = resolveTarget( target );\n    const accessorizedProps = _wq( target, 'accessorizedProps' );\n    function unaccessorizeProp( prop ) {\n        if ( !accessorizedProps.has( prop + '' ) ) return true;\n        return accessorizedProps.get( prop + '' ).restore();\n    }\n    const _props = Array.isArray( props ) ? props : (\n        props === undefined ? Object.keys( target ) : [ props ]\n    );\n    const statuses = _props.map( unaccessorizeProp );\n    return props === undefined || Array.isArray( props ) \n        ? statuses \n        : statuses[ 0 ];\n}\n\n/* ---------------PROXY METHODS--------------- */\n\n/**\n * Returns an object as a proxy and binds all instance methods\n * to the proxy instead of the object itself.\n *\n * @param Array|Object\t\ttarget\n * @param Object\t\t    params\n * @param Function\t\t    extendCallback\n *\n * @return Proxy\n */\nexport function proxy( target, params = {}, extendCallback = undefined ) {\n    // Resolve target\n    const originalTarget = resolveTarget( target );\n    // Return same proxy instance?\n    if ( typeof params.membrane === 'boolean' ) throw new Error( `The params.membrane parameter cannot be of type boolean.` );\n    if ( params.membrane && _wq( originalTarget, 'membraneRef' ).has( params.membrane ) ) { return _wq( originalTarget, 'membraneRef' ).get( params.membrane ); }\n    const traps = {\n        apply: ( target, thisArgument, argumentsList ) => apply( target, thisArgument, argumentsList, undefined, params ),\n        construct:  ( target, argumentsList, newTarget = null ) => construct( target, argumentsList, newTarget, params ),\n        defineProperty:  ( target, propertyKey, attributes ) => defineProperty( target, propertyKey, attributes, params ),\n        deleteProperty: ( target, propertyKey ) => deleteProperty( target, propertyKey, params ),\n        get: ( target, propertyKey, receiver = null ) => {\n            if ( propertyKey === symWQOriginal ) {\n                return originalTarget;\n            }\n            const $params = { ...params, receiver };\n            const returnValue = get( target, propertyKey, $params );\n            if ( Array.isArray( target ) && typeof returnValue === 'function' ) {\n                // Return a proxy, but in terms of a membrane. \n                return proxy( returnValue, { ...params, arrayMethodName: propertyKey, membrane: receiver/* the instance obj that will be the thisArgument at apply(). Much like function.bind() */ } );\n            }\n            return returnValue;\n        },\n        getOwnPropertyDescriptor: ( target, propertyKey ) => getOwnPropertyDescriptor( target, propertyKey, params ),\n        getPrototypeOf: target => getPrototypeOf( target, params ),\n        has: ( target, propertyKey ) => has( target, propertyKey, params ),\n        isExtensible: target => isExtensible( target, params ),\n        ownKeys: target => ownKeys( target, params ),\n        preventExtensions: target => preventExtensions( target, params ),\n        set: ( target, propertyKey, value, receiver = null ) => set( target, propertyKey, value, { ...params, receiver } ),\n        setPrototypeOf: ( target, prototype ) => setPrototypeOf( target, prototype, params ),\n    };\n    // Extend...\n    const $traps = extendCallback?.( traps ) || traps;\n    // Create proxy\n    const $proxy = new Proxy( originalTarget, $traps );\n    if ( params.membrane ) { _wq( originalTarget, 'membraneRef' ).set( params.membrane, $proxy ); }\n\treturn $proxy;\n}\n\n/**\n * Returns the original object earlier proxied by proxy().\n *\n * @param Proxy|Any\t\ttarget\n *\n * @return Any\n */\nexport function unproxy( target ) {\n    // Proxy targets are mapped to their own instances internally\n    return target && target[ symWQOriginal ] || target;\n}\n\n/* ---------------HELPERS--------------- */\n\n/** \n * Ensures target object is an object or array.\n *\n * @param Array|Object\ttarget\n *\n * @return Array|Object\n */\nfunction resolveTarget( target ) {\n\tif ( !target || !_isTypeObject( target ) ) throw new Error('Target must be of type object!');\n\treturn unproxy( target );\n}\n", "\n/**\n * @imports\n */\nimport * as main from './main.js';\nimport * as actors from './actors.js';\n\nconst Observer = { ...main, ...actors };\n\nexport default Observer;", "\nexport const _call = ( _function, ...args ) => {\n    const callback = args.pop();\n    if ( _function.constructor.name === 'AsyncFunction' ) return _await( _function.call( ...args ), callback );\n    try {\n        return callback( _function.call( ...args ) );\n    } catch( e ) { return callback( undefined, e ); }\n};\n\nexport const _await = ( maybePromise, callback ) => {\n    return maybePromise instanceof Promise ? maybePromise.then( callback ).catch( e => callback( undefined, e ) ) : callback( maybePromise )\n};\n\nexport const _isTypeObject = val => {\n\treturn ( typeof val === 'object' && val ) || typeof val === 'function';\n};\n\nexport function _$functionArgs( args ) {\n    const params = typeof args[ args.length - 1 ] === 'object' ? args.pop() : {};\n    const source = args.pop() || '';\n    params.functionParams = args;\n    return { source, params };\n}\n\nexport const env = {};\n", "\n/**\n * @exports\n */\nexport function resolveParams( ...extensions ) {\n    let extension, params = { runtimeParams, compilerParams, parserParams };\n    while( extension = extensions.shift() ) {\n        const {\n            runtimeParams: _runtimeParams = {},\n            compilerParams: { globalsNoObserve: _globalsNoObserve = [], globalsOnlyPathsExcept: _globalsOnlyPathsExcept = [], ..._compilerParams } = {},\n            parserParams: _parserParams = {},\n        } = extension;\n        params = {\n            runtimeParams: { ...params.runtimeParams, ..._runtimeParams },\n            compilerParams: { ...params.compilerParams, globalsNoObserve: [ ...params.compilerParams.globalsNoObserve, ..._globalsNoObserve ], globalsOnlyPathsExcept: [ ...params.compilerParams.globalsOnlyPathsExcept, ..._globalsOnlyPathsExcept ], ..._compilerParams },\n            parserParams: { ...params.parserParams, ..._parserParams },\n        };\n        if ( extensions.devMode ) { /* shortcut for devMode configs */ }\n    }\n    return params;\n}\nexport const parserParams = {\n    ecmaVersion: 'latest',\n    allowReturnOutsideFunction: true,\n    allowAwaitOutsideFunction: false,\n    allowSuperOutsideMethod: false,\n    preserveParens: false,\n    locations: true,\n};\nexport const compilerParams = {\n    globalsNoObserve: [ 'arguments', 'debugger', ],\n    globalsOnlyPathsExcept: [],\n    originalSource: true,\n    locations: true,\n    compact: 2,\n};\nexport const runtimeParams = {\n    apiVersion: 3,\n};\n", "\n/**\n * The modules registry\n */\nexport const registry = Object.create( null );", "/**\n * @imports\n */\nimport { env } from \"../util.js\";\n\nexport default class _EventTarget extends EventTarget {\n\n    managedAlways = new Set;\n    managedOnce = new Set;\n\n    constructor() {\n        super();\n        env.setMaxListeners?.( 0, this );\n    }\n\n    fire( evenName ) { return this.dispatchEvent( new Event( evenName, { cancelable: true } ) ); }\n\n    on( ...args ) {\n        this.addEventListener( ...args );\n        return () => this.removeEventListener( ...args );\n    }\n\n    abort( total = false ) {\n        this.managedAlways.forEach( x => x.abort ? x.abort( total ) : x( total ) );\n        this.managedOnce.forEach( x => x.abort ? x.abort( total ) : x( total ) );\n        this.managedOnce.clear();\n        this.fire( 'abort' );\n    }\n\n    manage( x ) { this.managedAlways.add( x ); }\n    once( x ) { this.managedOnce.add( x ); }\n\n}", "\n/**\n * @import\n */\nimport Observer from '@webqit/observer';\nimport { _isTypeObject } from '../util.js';\nimport EventTarget from './EventTarget.js';\n\nexport default class Signal extends EventTarget {\n\n    subscribers = new Set;\n    signals = new Map;\n\n    constructor( context, type, state ) {\n        super();\n        this.context = context;\n        this.context?.once( () => this.abort() );\n        this.once( () => this.watchMode( false ) );\n        this.type = type;\n        this.state = state;\n    }\n\n    get name() { return [ ...this.context?.signals.keys() || [] ].find( k => this.context.signals.get( k ) === this ); }\n   \n    signal( name, type = 'prop' ) {\n        let signal = this.signals.get( name );\n        if ( !signal ) {\n            // Initialization\n            signal = new Signal(\n                this,\n                type,\n                type === 'object' ? name : ( _isTypeObject( this.state ) ? Observer.get( this.state, name ) : undefined )\n            );\n            this.signals.set( name, signal );\n            // Self-start\n            if ( this.signals.size === 1 ) { this.watchMode(); }\n            // Cleanup\n            signal.once( () => {\n                // On being killed, auto-delete\n                this.signals.delete( name );\n                // On empty self-kill\n                if ( !this.signals.size ) { this.watchMode( false ); }\n            } );\n        }\n        return signal;\n    }\n\n    subscribe( autorun ) {\n        this.subscribers.add( autorun );\n        autorun.once( () => {\n            // Cleanup\n            this.subscribers.delete( autorun );\n            // On empty self-kill\n            if ( !this.subscribers.size ) { this.abort(); }\n        } );\n    }\n\n    watchMode( flag = true ) {\n        this.mutationsWatch?.abort();\n        if ( !flag || !this.signals.size || !_isTypeObject( this.state ) ) return;\n        this.mutationsWatch = Observer.observe( this.state, mutations => {\n            // Find subscribers and organize them by target runtime\n            const groupings = { map: new Map, add( autoruns, mutation ) {\n                for ( const autorun of autoruns ) {\n                    if ( autorun.spec.beforeSchedule?.( mutation ) === false ) continue;\n                    if ( !this.map.has( autorun.runtime ) ) { this.map.set( autorun.runtime, new Set ); }\n                    this.map.get( autorun.runtime ).add( autorun );\n                }\n            } };\n            for ( const mutation of mutations ) {\n                const signal = this.signals.get( mutation.key );\n                if ( !signal ) continue;\n                groupings.add( signal.subscribers, mutation );\n                signal.refresh( mutation.value );\n            }\n            // Dispatch to runtimes...\n            const runtimesMap = !groupings.map.size ? groupings.map : [ ...groupings.map ].sort( ( a, b ) => a.$serial > b.$serial ? -1 : 1 );\n            //const runtimesMap = groupings.map;\n            for ( const [ runtime, autoruns ] of runtimesMap ) {\n                if ( runtime.state === 'aborted' ) continue;\n                runtime.schedule( ...autoruns );\n            }\n        }, { recursions: 'force-sync' } );\n    }\n\n    refresh( newState ) {\n        this.state = newState;\n        for ( const [ name, signal ] of this.signals ) {\n            signal.refresh( Observer.get( this.state ?? {}, name ) );\n        }\n        this.watchMode();\n    }\n\n}", "\n/**\n * @import\n */\nimport Signal from './Signal.js';\n\nexport default class Scope extends Signal {\n\n    symbols = new Map;\n    constructor( context, type, state = undefined ) {\n        super( context, type, state || Object.create( null ) );\n    }\n\n}", "\n/**\n * @import\n */\nimport Observer from '@webqit/observer';\nimport { _await, _call } from '../util.js';\nimport EventTarget from './EventTarget.js';\nimport Scope from './Scope.js';\n\nexport default class Autorun extends EventTarget {\n\n    state;\n\n    constructor( context, type, spec, serial, scope, closure ) {\n        super();\n        // We are to be managed by context\n        context?.once( this );\n        this.context = context;\n        this.type = type;\n        this.spec = spec || {};\n        this.scope = scope;\n        if ( context?.scope !== scope ) {\n            // It's own scope, so we manage it\n            this.manage( scope );\n        }\n        this.serial = serial;\n        if ( closure ) { this.closure = closure; }\n        if ( context?.type === 'iteration' ) { this.path = context.path.concat( this.spec.index ); }\n        else if ( context?.type === 'round' ) { this.path = context.path.concat( this.serial ); }\n        else { this.path = ( context?.path || [] ).slice( 0, -1 ).concat( this.serial ); }\n        this.flowControl = new Map;\n    }\n\n    get runtime() { return this.context.runtime; }\n\n    contains( node ) { return this === node.context || ( node.context && this.contains( node.context ) ); }\n\n    order( node ) {\n        if ( !node ) return this;\n        const [ a, b ] = node.path.length < this.path.length ? [ node, this ] : [ this, node ];\n        return a.path.reduce( ( prev, key, i ) => {\n            return prev && key <= b.path[ i ];\n        }, true ) && a || b;\n    }\n\n    beforeExecute() {\n        this.state = 'running';\n        // Get record and reset\n        const flowControlBefore = this.flowControl;\n        this.flowControl = new Map;\n        return flowControlBefore;\n    }\n\n    execute( callback = null ) {\n        this.runtime.thread.unshift( this );\n        return _await( this.beforeExecute(), stateBefore => {\n            return _call( this.closure, this, this, ( returnValue, exception ) => {\n                if ( exception ) return this.throw( exception, [ this.serial, this.context?.serial ], exception.code );\n                if ( this.spec.complete ) { returnValue = this.spec.complete( returnValue, this ); }\n                this.afterExecute( stateBefore );\n                this.runtime.thread.shift();\n                return callback ? callback( returnValue, this ) : returnValue;\n            } );\n        } );\n    }\n\n    throw( e, serials, errorCode ) {\n        if ( this.type === 'function' && [ 'HandlerFunction', 'FinalizerFunction' ].includes( this.$params.executionMode ) ) {\n            // Hoist control further above the context that handed it to us\n            return this.$params.lexicalContext.throw( e, serials, errorCode );\n        } else if ( this.spec.handler ) return this.spec.handler( e );\n        else if ( this.type !== 'function' && this.context ) return this.context.throw( e, serials, errorCode );\n        if ( e.cause ) throw e;\n        // Message\n        const message = `${ e.message || e }`;\n        const $message = errorCode !== null ? `[${ errorCode }]: ${ message }` : message;\n        // Cause\n        const cause = serials.map( serial => serial !== -1 && this.extractSource( serial, true ) ).filter( x => x );\n        cause.push( { source: this.runtime.$params.originalSource } );\n        // Type\n        const ErrorClass = globalThis[ e.name ];\n        const error = new ( ErrorClass || Error )( $message, { cause } );\n        // File\n        const fileName = this.runtime.$params.sourceType === 'module' && this.$params.experimentalFeatures !== false && this.$params.exportNamespace || this.$params.fileName;\n        if ( fileName ) { error.fileName = fileName; }\n        if ( errorCode ) { error.code = errorCode; }\n        throw error;\n    }\n\n    afterExecute( flowControlBefore ) {\n        this.state = 'complete';\n        // Compare records... and hoist differences\n        const flowControlAfter = this.flowControl;\n        if ( this.spec.finalizer ) this.spec.finalizer();\n        // Handle downstream\n        this.handleDownstream( flowControlAfter.size, flowControlBefore.size );\n        this.handleRightstream( flowControlAfter.size, flowControlBefore.size );\n        for ( const cmd of [ 'break', 'continue', 'return' ] ) {\n            if ( flowControlAfter.has( cmd ) && !flowControlAfter.get( cmd ).endpoint ) { this.hoistFlowControl( cmd, flowControlAfter.get( cmd ).arg ); }\n            else if ( flowControlBefore.has( cmd ) && !flowControlBefore.get( cmd ).endpoint ) { this.hoistFlowControl( cmd, flowControlBefore.get( cmd ).arg, true ); }\n        }\n    }\n\n    typed( as, value, name = undefined ) {\n        const valueType = Array.isArray( value ) ? 'array' : ( value === null ? 'null' : typeof value );\n        if ( valueType === as || ( as === 'iterable' && value?.[ Symbol.iterator ] ) || ( as === 'desctructurable' && ![ 'undefined', 'null' ].includes( valueType ) ) ) return value;\n        if ( as === 'iterable' ) { throw new Error( `value is not iterable.` ); }\n        if ( as === 'desctructurable' ) { throw new Error( ( name ? `Cannot access ${ name }; ` : '' ) + `object not desctructurable.` ); }\n        throw new Error( `value must be of type ${ as }.` );\n    }\n\n    let( name, serial, closure, spec = {} ) { return this.var( name, serial, closure, { ...spec, kind: 'let' } ); }\n\n    const( name, serial, closure, spec = {} ) { return this.var( name, serial, closure, { ...spec, kind: 'const' } ); }\n\n    var( name, serial, closure, spec = {} ) {\n        spec = { kind: 'var'/* as default */, ...spec };\n        // Uninitialized declarations like: let a;\n        if ( !closure ) closure = () => undefined;\n        const $closure = !spec.restOf ? closure : ( ...args ) => {\n            try { return closure( ...args ); }\n            catch( e ) { throw new Error( `Cannot declare ${ name }; ${ e.message }` ); }\n        };\n        const complete = ( returnValue, autorun ) => {\n            let scope = autorun.scope;\n            if ( spec.kind === 'var' ) {\n                //let scope = this.runtime.scope;\n                // For plain scripts, hoist all the way to the global scope... or somewhere before where its been defined\n                while ( ![ 'module', 'function' ].includes( scope.type ) && !Observer.has( scope.state, name ) && scope.context ) {\n                    scope = scope.context;\n                }\n            } else if ( scope.type === 'this' && scope.context ) {\n                // We're in a script or module program. scope.context is either going to be 'env' or 'module'\n                scope = scope.context;\n            }\n            let symbolState = scope.symbols.get( name );\n            if ( symbolState && ( symbolState.kind !== spec.kind || ( spec.kind === 'let' && symbolState.serial !== serial ) ) ) {\n                throw new Error( `Identifier \"${ name }\" has already been declared.` );\n            }\n            symbolState?.reader?.abort(); // Any previous reader? Type \"var\" cannot rely on autorun lifecycle cleanup\n            symbolState = { serial, kind: spec.kind }; // New state!\n            let assignedValue = returnValue;\n            if ( spec.restOf ) {\n                if ( spec.type === 'array' ) {\n                    assignedValue = [];\n                } else { assignedValue = {}; }\n                symbolState.reader = Observer.map( returnValue, assignedValue, { except: spec.restOf, spread: spec.type === 'array' } );\n                autorun.once( symbolState.reader ); // Lifecycle cleanup\n            }\n            scope.symbols.set( name, symbolState );\n            Observer.set( scope.state, name, assignedValue );\n            return assignedValue;\n        };\n        return this.autorun( spec.kind, { complete, ...spec }, serial, $closure );\n    }\n\n    update( name, closure, spec = {} ) {\n        // Find lexical scope\n        let lexicalScope = this.scope;\n        while( lexicalScope && !Observer.has( lexicalScope.state, name ) ) { lexicalScope = lexicalScope.context; }\n        // Validation\n        if ( !lexicalScope ) { throw new ReferenceError( `${ name } is not defined.` ); }\n        let symbolState = lexicalScope.symbols.get( name );\n        if ( symbolState?.kind === 'const' ) { throw new ReferenceError( `Assignment to constant variable \"${ name }\".` ); }\n        const valueBefore = Observer.get( lexicalScope.state, name );\n        const $closure = !spec.restOf ? closure : ( ...args ) => {\n            try { return closure( ...args ); }\n            catch( e ) { throw new Error( `Cannot update ${ name }; ${ e.message }` ); }\n        };\n        return _call( $closure, undefined, valueBefore, ( returnValue, exception ) => {\n            if ( exception ) return this.throw( exception, [ this.serial ] );\n            // Operation\n            symbolState?.reader?.abort(); // Any previous reader?\n            let assignedValue = returnValue;\n            if ( spec.restOf ) {\n                symbolState = symbolState || {}; // New state!\n                if ( spec.type === 'array' ) {\n                    assignedValue = [];\n                } else { assignedValue = {}; }\n                symbolState.reader = Observer.map( returnValue, assignedValue, { except: spec.restOf, spread: spec.type === 'array' } );\n                this.once( symbolState.reader ); // Lifecycle cleanup\n            }\n            Observer.set( lexicalScope.state, name, assignedValue );\n            return [ 'postinc', 'postdec' ].includes( spec.kind ) ? valueBefore : assignedValue;\n        } );\n    }\n\n    ref( name, ...rest ) {\n        let depth = 0, hint = {};\n        if ( typeof rest[ 0 ] === 'number' ) {\n            depth = rest.shift();\n            hint = rest.shift() || {};\n        } else if ( typeof rest[ 0 ] === 'object' ) {\n            hint = rest.shift();\n        }\n        // Find lexical scope\n        let lexicalScope = this.scope;\n        while( lexicalScope && !Observer.has( lexicalScope.state, name ) ) {\n            lexicalScope = lexicalScope.context;\n        }\n        // Not found?\n        if ( !lexicalScope ) {\n            if ( hint.isTypeCheck ) return;\n            throw new Error( `${ name } is not defined.` );\n        }\n        // Bind now?\n        const kind = lexicalScope.symbols.get( name )?.kind;\n        const baseSignal = lexicalScope.signal( name, kind );\n        if ( hint.typed ) { this.typed( hint.typed, baseSignal.state, name ); }\n        return this.autobind( baseSignal, depth, hint );\n    }\n\n    obj( val, ...rest ) {\n        let depth = 0, hint = {};\n        if ( typeof rest[ 0 ] === 'number' ) {\n            depth = rest.shift();\n            hint = rest.shift() || {};\n        } else if ( typeof rest[ 0 ] === 'object' ) {\n            hint = rest.shift();\n        }\n        return this.autobind( this.runtime.$objects.signal( val, 'object' ), depth, hint );\n    }\n\n    autobind( baseSignal, depth, hint ) {\n        const quantumMode = [ 'QuantumProgram', 'QuantumFunction' ].includes( this.runtime.$params.executionMode );\n        const isConst = baseSignal.type  === 'const';\n        const isRuntime = this === this.runtime;\n        const isAborted = this.state === 'aborted';\n        const isStatic = this.spec.static;\n        const nowRunning = this;\n        return ( function proxy( signal, depth ) {\n            // Do bindings first\n            if ( quantumMode && !isStatic && !isConst && !isRuntime && !isAborted ) {\n                signal.subscribe( nowRunning );\n            }\n            // Return bare value here?\n            if ( !depth || !signal.state || typeof signal.state !== 'object' ) {\n                let returnValue = signal.state;\n                if ( typeof signal.state === 'function' && !/^class\\s?/.test(Function.prototype.toString.call(signal.state)) ) {\n                    // We're returning a proxy for functions instead of: signal.context.state[ signal.name ].bind( signal.context.state );\n                    returnValue = Observer.proxy( signal.state, { membrane: signal } );\n                }\n                return returnValue;\n            }\n            // Return dynamic value\n            let propertyAlreadyBound;\n            return Observer.proxy( signal.state, {}, traps => ( {\n                ...traps,\n                get( target, name, receiver = null ) {\n                    // Constructs are always going to for one property access: ref('a').b, and we need to prevent .c from creating a binding\n                    if ( propertyAlreadyBound ) { return traps.get( target, name, receiver ); }\n                    propertyAlreadyBound = true;\n                    return proxy( signal.signal( name ), depth - 1 );\n                },\n            } ) );\n        } )( baseSignal, depth );\n    }\n\n    autorun( type, ...rest ) {\n        let closure = rest.pop();\n        const serial = rest.pop();\n        const spec = rest.pop() || {};\n        // Handle certain types with their own class\n        let AutorunClass = Autorun, scope = this.scope;\n        if ( type === 'iteration' ) {\n            const staticDefs = this.runtime.constructor;\n            AutorunClass = closure.constructor.name === 'AsyncFunction' ? staticDefs.AutoAsyncIterator : staticDefs.AutoIterator;\n        }\n        if ( [ 'block', 'switch', 'iteration' ].includes( type ) ) { scope = new Scope( scope, type ); }\n        // Instantiate\n        const autorun = new AutorunClass( this, type, spec, serial, scope, closure );\n        if ( type === 'downstream' ) {\n            // Declare a \"downstream\" for the context\n            this.downstream = autorun;\n            // For now\n            if ( this.flowControlApplied() ) return;\n        } else if ( this.type === 'switch' && this.breakpoint ) {\n            return;\n        }\n        // Push stack and execute\n        return autorun.execute();\n    }\n\n    function( executionMode, functionKind, serial, $qFunction ) {\n        // Declare in current scope\n        if ( functionKind === 'Declaration' ) {\n            Observer.set( this.scope.state, $qFunction.name, $qFunction );\n        }\n        // Metarise function\n        const _this = this;\n        Object.defineProperty( $qFunction, 'toString', { value: function( $qSource = false ) {\n            if ( $qSource && executionMode === 'QuantumFunction' ) return Function.prototype.toString.call( $qFunction );\n            const originalSource = _this.runtime.extractSource( serial );\n            return originalSource.startsWith( 'static ' ) ? originalSource.replace( 'static ', '' ) : originalSource;\n        } } );\n        return $qFunction;\n    }\n\n    class( classKind, $class, methodsSpec ) {\n        // Declare in current scope\n        if ( classKind === 'Declaration' ) {\n            Observer.set( this.scope.state, $class.name, $class );\n        }\n        // Metarise methods\n        methodsSpec.forEach( ( { name, isQuantumFunction, static: isStatic, serial } ) => {\n            this.function( isQuantumFunction && 'QuantumFunction' || 'RegularFunction', 'Expression', serial, isStatic ? $class[ name ] : $class.prototype[ name ] )\n        } );\n        return $class;\n    }\n\n    async import( ...args ) { return this.runtime.import( ...args ); }\n\n    async export( ...args ) { return this.runtime.export( ...args ); }\n\n    continue( label ) { return this.applyFlowControl( 'continue', label ); }\n\n    break( label ) { return this.applyFlowControl( 'break', label ); }\n\n    return( arg ) { return this.applyFlowControl( 'return', arg ); }\n\n    applyFlowControl( cmd, arg, unset = false ) {\n        const sizeBefore = this.flowControl.size;\n        if ( unset ) { this.flowControl.delete( cmd ); }\n        else { this.flowControl.set( cmd, { arg } ); }\n        if ( this.type === 'round' ) { this.context.breakpoint = this; }\n        if ( this.type === 'round' && [ 'break', 'continue' ].includes( cmd ) && arg === this.context?.spec.label ) {\n            if ( !unset ) { this.flowControl.get( cmd ).endpoint = true; }\n            if ( this.state !== 'running' ) { this.handleRightstream( this.flowControl.size, sizeBefore ); }\n            return;\n        }\n        if ( this.context?.type === 'switch' && cmd === 'break' && !arg ) {\n            if ( !unset ) { this.flowControl.get( cmd ).endpoint = true; }\n            this.context.breakpoint = this;\n            return;\n        }\n        // Notice that no hoisting and no \"downstream\" handling if in active scope\n        // as that would be done at after() hook!\n        if ( this.state !== 'running' ) {\n            this.handleDownstream( this.flowControl.size, sizeBefore );\n            this.hoistFlowControl( ...arguments );\n        }\n    }\n\n    hoistFlowControl( ...args ) { return this.context?.applyFlowControl( ...args ); }\n\n    flowControlApplied( cmd, arg ) {\n        if ( !arguments.length ) return this.flowControl.size || false;\n        if ( arguments.length === 1 ) return this.flowControl.has( cmd );\n        return this.flowControl.get( cmd )?.arg === arg;\n    }\n\n    handleDownstream( sizeAfter, sizeBefore ) {\n        let downstream;\n        if ( ![ 'block' ].includes( this.type ) // If this is \"downstream\", the \"downstream\" you see from parent scope will be self\n        || !( downstream = this.context?.downstream ) ) return;\n        if ( sizeAfter ) { downstream.abort(); }\n        else if ( sizeBefore ) {\n            downstream.state = 'resuming'; // Just something other than \"aborted\"\n            this.runtime.schedule( downstream );\n        }\n    }\n\n    handleRightstream( sizeAfter, sizeBefore ) {\n        if ( this.type !== 'round' ) return;\n        let nextRound = this, returnees = new Set;\n        while( nextRound = nextRound.nextRound ) {\n            if ( sizeAfter ) { nextRound.abort(); }\n            else if ( sizeBefore && nextRound.state !== 'inert' ) {\n                nextRound.state = 'resuming'; // Just something other than \"aborted\"\n                returnees.add( nextRound );\n            }\n        }\n        if ( returnees.size ) { this.runtime.schedule( ...returnees ); }\n        if ( !sizeAfter && sizeBefore ) {\n            this.runtime.on( 'reflection', () => {\n                if ( this.context.iterating ) return;\n                this.context.iterate();\n            }, { once: true } );\n        }\n    }\n\n    abort( total = false ) {\n        if ( total ) {\n            if ( this.context?.breakpoint === this ) { delete this.context.breakpoint; }\n            this.flowControl.clear();\n        }\n        this.state = total ? 'inert' : 'aborted';\n        return super.abort( total );\n    }\n    \n}", "\n/**\n * @import\n */\nimport { _await } from '../util.js';\nimport Observer from '@webqit/observer';\nimport Autorun from './Autorun.js';\nimport Scope from './Scope.js';\n\nexport default class AutoIterator extends Autorun {\n\n    rounds = new Map;\n\n    constructor( context, type, spec, serial, scope, closure ) {\n        spec.$closure = closure;\n        super( context, type, spec, serial, scope );\n        this.manage( () => {\n            delete this.breakpoint;\n            this.rounds.clear();\n        } );\n    }\n\n    pseudorun( callback ) {\n        this.runtime.iThread.unshift( this );\n        return _await( callback(), returnValue => {\n            this.runtime.iThread.pop();\n            return returnValue;\n        } );\n    }\n\n    createIterator() {\n        if ( this.spec.kind === 'for-in' ) return ( function* () { for ( let key in this.iteratee ) yield key; } ).call( this );\n        if ( this.spec.kind === 'for-of' ) return ( function* () { for ( let val of this.iteratee ) yield val; } ).call( this );\n        return { next: () => ({ done: !this.pseudorun( () => this.spec.test( this ) ), }), };\n    }\n\n    closure() {\n        if ( [ 'for-of', 'for-in' ].includes( this.spec.kind ) ) {\n            [ this.production, this.iteratee ] = this.spec.parameters( this );\n            this.iterator = this.createIterator();\n            this.iterator.original = true;\n            this.watchMode();\n        } else {\n            if ( this.spec.kind === 'for' ) { this.spec.init( this ); }\n            this.iterator = this.createIterator();\n        }\n        this.iterate();\n    }\n\n    terminated() { return this.breakpoint && !this.breakpoint.flowControlApplied( 'continue', this.spec.label ) && this.breakpoint.flowControlApplied(); }\n    advance() { if ( this.spec.kind === 'for' ) { this.pseudorun( () => this.spec.advance( this ) ); } }\n\n    iterate() {\n        this.iterating = true;\n        const $test = () => !this.terminated()/* must come before */ && !( this.cursor = this.iterator.next() ).done;\n        const $round = () => {\n            const round = this.createRound( this.cursor.value );\n            round.execute();\n            this.advance();\n        };\n        if ( this.spec.kind === 'do-while' ) { do $round(); while ( $test() ); }\n        else { while ( $test() ) $round(); }\n        this.iterating = false;\n    }\n\n    createRound( production ) {\n        const index = this.rounds.size, spec = { index };\n        // The scope instance starts life with the variables that the iteration round should see.\n        const state = [ 'for-in', 'for-of' ].includes( this.spec.kind ) ? { [ this.production ]: production } : { ...this.scope.state };\n        const scope = new Scope( this.scope, 'round', state );\n        this.scope.symbols.forEach( ( meta, name ) => { scope.symbols.set( name, meta ); } );\n        const round = new Autorun( this, 'round', spec, this.serial, scope, this.spec.$closure );\n        const key = this.spec.kind === 'for-in' ? production : index;\n        this.rounds.set( key, round );\n        if ( this.lastRound ) {\n            this.lastRound.nextRound = round;\n            round.prevRound = this.lastRound;\n        }\n        this.lastRound = round;\n        return round;\n    }\n\n    watchMode() {\n        if ( this.spec.static ) return;\n        const handleMutations = ( mutations, currentCursor ) => {\n            const deletions = new Set, extension = new Set;\n            for ( const mutation of mutations ) {\n                if ( Array.isArray( this.iteratee ) && mutation.key === 'length' ) continue;\n                const production = this.spec.kind === 'for-in' ? mutation.key : mutation.value;\n                const key = this.spec.kind === 'for-in' ? mutation.key : parseInt( mutation.key );\n                const existingRound = this.rounds.get( key ); // Note that we're not using has()\n                if ( existingRound ) {\n                    // This is an existing round\n                    Observer.set( existingRound.scope.state, this.production, production );\n                    if ( mutation.type === 'delete' ) {\n                        this.rounds.set( key, undefined ); // No actual deletions here as this.rounds.size is our index\n                        if ( existingRound.prevRound ) { existingRound.prevRound.nextRound = existingRound.nextRound; }\n                        if ( existingRound.nextRound ) { existingRound.nextRound.prevRound = existingRound.prevRound; }\n                        // Fired above for the last time and now should die\n                        deletions.add( existingRound );\n                    }\n                } else if ( mutation.type !== 'delete' && !mutation.isUpdate ) {\n                    // This is a brand new entry\n                    // Deletions and updates that didn't have an existing round above are obviously awaiting visit from a paused loop\n                    if ( this.spec.kind === 'for-of' && this.iterator.original && !currentCursor.done ) continue; // A live iteration is going on\n                    extension.add( production );\n                }\n            }\n            this.runtime.on( 'reflection', () => {\n                deletions.forEach( deletion => deletion.abort( true ) );\n            }, { once: true } );\n            if ( extension.size ) {\n                this.iterator = ( function* ( parent ) {\n                    yield* parent;\n                    yield* extension;\n                } )( this.iterator );\n                if ( currentCursor.done ) { this.iterate(); }\n            }\n        };\n        this.once( Observer.observe( this.iteratee, mutations => {\n            _await( this.cursor, currentCursor => handleMutations( mutations, currentCursor ) );\n        } ) );\n    }\n    \n}", "\n/**\n * @import\n */\nimport AutoIterator from './AutoIterator.js';\n\nexport default class AutoAsyncIterator extends AutoIterator {\n\n    async createIterator() {\n        if ( this.spec.kind === 'for-in' ) return ( function* () { for ( let key in this.iteratee ) yield key; } ).call( this );\n        if ( this.spec.kind === 'for-of' ) return ( function* () { for ( let val of this.iteratee ) yield val; } ).call( this );\n        return { next: async () => ({ done: !( await this.pseudorun( () => this.spec.test( this ) ) ), }), };\n    }\n\n    async closure() {\n        if ( [ 'for-of', 'for-in' ].includes( this.spec.kind ) ) {\n            [ this.production, this.iteratee ] = await this.spec.parameters( this );\n            this.iterator = await this.createIterator();\n            this.iterator.original = true;\n            this.watchMode();\n        } else {\n            if ( this.spec.kind === 'for' ) { await this.spec.init( this ); }\n            this.iterator = await this.createIterator();\n        }\n        await this.iterate();\n    }\n\n    async iterate() {\n        let cursor; this.iterating = true;\n        const $test = async () => ( !this.terminated()/* must come before */ && ( this.cursor = this.iterator.next() ) && ( cursor = await this.cursor ) && !cursor.done );\n        const $round = async () => {\n            const round = this.createRound( cursor.value );\n            await round.execute();\n            await this.advance();\n        };\n        if ( this.spec.kind === 'do-while' ) { do await $round(); while ( await $test() ); }\n        else { while ( await $test() ) await $round(); }\n        this.iterating = false;\n    }\n\n}", "\n/**\n * @imports\n */\nimport Observer from \"@webqit/observer\";\n\nexport default class State {\n\n    constructor( runtime ) {\n        Object.defineProperty( this, 'runtime', { value: runtime } );\n        const events = { statechange: () => { Observer.defineProperty( this, 'value', { value: runtime.flowControl.get( 'return' )?.arg, enumerable: true, configurable: true } ); }, };\n        for ( const name in events ) {\n            runtime.on( name, events[ name ] );\n            events[ name ]();\n        }\n        if ( runtime.$params.sourceType === 'module' ) {\n            Object.defineProperty( this, 'exports', { value: runtime.exports } );\n        }\n    }\n    \n    dispose() { return this.runtime.abort( true ); }\n\n}\n", "import Observer from '@webqit/observer';\nimport { _await } from '../util.js';\nimport { registry } from './hot-module-registry.js';\nimport AutoAsyncIterator from './AutoAsyncIterator.js';\nimport AutoIterator from './AutoIterator.js';\nimport Autorun from './Autorun.js';\nimport Scope from './Scope.js';\nimport State from './State.js';\n\nexport default class Runtime extends Autorun {\n\n    static AutoAsyncIterator = AutoAsyncIterator;\n    static AutoIterator = AutoIterator;\n\n    locations = [];\n    queue = new Set;\n    thread = [];\n    iThread = [];\n\n    constructor( context, type, params, scope, closure ) {\n        const { $serial = 0, spec, ...$params } = params;\n        super( context, type, spec, -1, scope, closure );\n        this.$serial = $serial;\n        this.$params = $params;\n        // Random object\n        this.$objects = new Scope( undefined, 'objects' );\n        this.manage( this.$objects );\n        // Imports/exports\n        this.exports = Object.create( null );\n        this.$promises = { imports: [], exports: [] };\n        this.manage( () => {\n            Observer.deleteProperties( this.exports, Object.keys( this.exports ) );\n            this.$promises.imports.splice( 0 );\n            this.$promises.exports.splice( 0 );\n        } );\n    }\n\n    extractSource( serial, full = false ) {\n        const [ [ locStart, line, column ], [ locEnd ] ] = this.locations[ serial ];\n        const expr = this.$params.originalSource.slice( locStart, locEnd );\n        return full ? { expr, line, column } : expr;\n    }\n\n    get runtime() { return this; }\n\n    get nowRunning() { return this.thread[ 0 ]; }\n\n    schedule( ...autoruns ) {\n        // Determine if active beforehand\n        const isActive = this.queue.size;\n        for ( const autorun of autoruns ) { this.queue.add( autorun ); }\n        if ( isActive ) return;\n        // Event Loop\n        this.flowControlDirty = false;\n        return ( function nextTick( prevReturn, current ) {\n            // Find following...\n            let following;\n            for ( const autorun of this.queue ) {\n                // If autorun is higher in source ignore\n                // Or a parent autorun has already been run in this event loop which started by aborting all descendants\n                // Or the unique situation with \"for\" loops where \"test\" and \"update\" expressions tend to self-schedule the AutoIteration instance.\n                if ( current && current.order( autorun ) !== current || [ 'aborted', 'running' ].includes( autorun.state ) || this.iThread[ 0 ]?.contains( autorun ) ) {\n                    this.queue.delete( autorun ); continue;\n                }\n                // Get $autorun to be very next to _this.currentMicro\n                following = following ? following.order( autorun ) : autorun;\n                if ( !current ) { current = following; }\n            }\n            // Fire events\n            if ( !following ) {\n                this.fire( 'reflection' );\n                if ( this.flowControlApplied() ) { this.fire( 'statechange' ); }\n                return prevReturn;\n            }\n            // Execute following...\n            following.abort();\n            // Evaluate and possibly await...\n            return following.execute( returnValue => {\n                // Remove from queue\n                this.queue.delete( following );\n                // Next tick\n                return nextTick.call( this, returnValue, following );\n            } );\n        } ).call( this, undefined, this.nowRunning );\n    }\n\n    execute( callback = null ) {\n        return super.execute( returnValue => {\n            const quantumMode = [ 'QuantumProgram', 'QuantumFunction' ].includes( this.$params.executionMode );\n            const actualReturnValue = quantumMode\n                ? new State( this )\n                : this.flowControl.get( 'return' )?.arg;//returnValue;\n            return callback ? callback( actualReturnValue, this ) : actualReturnValue;\n        } );\n    }\n\n    spawn( executionMode, thisContext, closure, lexicalContext = null ) {\n        const context = this.nowRunning || lexicalContext || this;\n        const params = { ...this.$params, $serial: this.$serial + 1, executionMode, lexicalContext };\n        const scope = new Scope( context.scope, 'function', { [ 'this' ]: thisContext } );\n        const subRuntime = new this.constructor( context, 'function', params, scope, closure );\n        return subRuntime.execute();\n    }\n\n    async import( ...args ) {\n        const source = args.pop();\n        const $source = typeof source === 'string' ? { source } : source;\n        const onload = modules => {\n            if ( $source.forExport || $source.isDynamic ) return modules;\n            this.assignModules( args, this.scope.state, modules, source.serial );\n        };\n        if ( this.$params.experimentalFeatures !== false && registry[ $source.source ] ) {\n            return onload( registry[ $source.source ] );\n        }\n        const promise = ( async () => {\n            const moduleName = this.$params.sourceType === 'module' && this.$params.experimentalFeatures !== false && this.$params.exportNamespace || this.$params.fileName;\n            try { return onload( { ...await import( $source.source ) } ); } catch( e ) {\n                if ( e.code === 'ERR_MODULE_NOT_FOUND' ) { this.throw( new Error( `Cannot find module \"${ $source.source }\"${ moduleName ? ` imported at \"${ moduleName }\"` : '' }.` ), [ $source.serial ], e.code ); }\n                else this.throw( e, [ $source.serial ], e.code );\n            }\n        } )();\n        if ( !$source.isDynamic ) {\n            this.$promises[ $source.forExport ? 'exports' : 'imports' ].push( promise );\n        }\n        return promise;\n    }\n\n    async export( ...args ) {\n        const source = !Array.isArray( args[ args.length - 1 ] ) ? args.pop() : null;\n        // Export from source or from top-level scope!\n        const modules = source ? await this.import( { ...source, forExport: true } ) : this.scope.state;\n        // Assign imported modules to exports object\n        this.assignModules( args, this.exports, modules, source?.serial );\n    }\n\n    assignModules( specifiers, target, source, sourceSerial = null ) {\n        const observeList = [];\n        const quantumMode = [ 'QuantumProgram', 'QuantumFunction' ].includes( this.$params.executionMode );\n        for ( const [ local, serial, alias ] of specifiers ) {\n            if ( local === '*' && alias ) {\n                ( quantumMode ? Observer : Reflect ).set( target, alias, source );\n                continue;\n            }\n            if ( !Observer.has( source, local ) ) { this.throw( new Error( `The requested module does not provide an export named \"${ local }\".` ), [ serial, sourceSerial ] ); }\n            ( quantumMode ? Observer : Reflect ).set( target, alias || local, Observer.get( source, local ) );\n            observeList.push( [ local, serial, alias ] );\n        }\n        if ( !observeList.length || !quantumMode ) return;\n        this.once( Observer.observe( source, mutations => {\n            for ( const [ local, /* serial */, alias ] of observeList ) {\n                for ( const mutation of mutations ) {\n                    if ( local === '*' ) { Observer.set( target, mutation.key, mutation.value ); }\n                    else if ( mutation.key === local ) { Observer.set( target, alias || local, mutation.value ); }                    \n                }\n            }\n        } ) );\n    }\n    \n    afterExecute( ...args ) {\n        if ( this.$params.sourceType === 'module' && this.$params.experimentalFeatures !== false && this.$params.exportNamespace ) {\n            registry[ this.$params.exportNamespace ] = this.exports;\n            this.once( () => { delete registry[ this.$params.exportNamespace ]; } );\n        }\n        return super.afterExecute( ...args );\n    }\n\n}", "\n/**\n * @imports\n */\nimport { _await } from '../util.js';\nimport { resolveParams } from '../params.js';\nimport Runtime from './Runtime.js';\nimport Scope from './Scope.js';\nimport State from './State.js';\n\nexport { State, Runtime }\n\nexport function $eval( sourceType, parseCompileCallback, source, params ) {\n    // params could have: env, functionParams, parserParams, compilerParams, runtimeParams\n    const { env, functionParams = [], exportNamespace, fileName } = params;\n    const { parserParams, compilerParams, runtimeParams, } = resolveParams( params );\n    const inBrowser = Object.getOwnPropertyDescriptor( globalThis, 'window' )?.get?.toString().includes( '[native code]' ) ?? false;\n    const asyncEval = [ 'async-script', 'module' ].includes( sourceType );\n\n    // Format source? Mode can be: function, async-function, script, async-script, module\n    if ( sourceType === 'module' ) {\n        parserParams.sourceType = sourceType;\n        parserParams.allowAwaitOutsideFunction = true;\n    } else if ( [ 'function', 'async-function' ].includes( sourceType ) ) {\n        // Design the actual stateful function\n        const body = `  ` + source.split( `\\n` ).join( `\\n  ` );\n        source = `return ${ sourceType === 'async-function' ? 'async ' : '' }function**(${ functionParams.join( ', ' ) }) {\\n${ body }\\n}`;\n        // The top-level program is a simple return statement as above. This return shouldn't be treated as reactive nor return a state object, but the plain value\n        parserParams.executionMode = 'RegularProgram';\n    } else if ( ![ 'script', 'async-script' ].includes( sourceType ) ) {\n        throw new Error( `Unrecognized sourceType specified: \"${ sourceType }\".` );\n    }\n\n    // Proceed to parse-compile\n    compilerParams.sourceType = sourceType;\n    parserParams.inBrowser = inBrowser;\n    compilerParams.base64 = asyncEval && inBrowser && `export default async function(%0) {%1}`;\n    const compilation = parseCompileCallback( source, { parserParams, compilerParams } );\n    if ( compilation instanceof Promise && ![ 'async-function', 'async-script', 'module' ].includes( sourceType ) ) {\n        throw new Error( `Parse-compile can only return a Promise for sourceTypes: async-function, async-script, module.` );\n    }\n\n    // Proceed to eval\n    runtimeParams.sourceType = sourceType;\n    runtimeParams.inBrowser = inBrowser;\n    runtimeParams.exportNamespace = exportNamespace;\n    runtimeParams.fileName = fileName;\n    return _await( compilation, compilation => {\n        const isFunction = [ 'function', 'async-function' ].includes( sourceType );\n        // Below, \"async-function\" would already has async in the returned function\n        // And no need to ask compilation.topLevelAwait\n        const $eval = ( $qIdentifier, source ) => {\n            if ( runtimeParams.compileFunction ) return runtimeParams.compileFunction( source.toString(), [ $qIdentifier ] );\n            if ( compilerParams.base64 ) { /* @experimental */\n                // Save to a variable to fool bundlephobia about the import();\n                const dataUrl = `data:text/javascript;base64,${ source.toString( 'base64' ) }`;\n                const impt = () => import( dataUrl ).then( m => m.default );\n                //if ( window.webqit?.realdom?.schedule ) return window.webqit?.realdom?.schedule( 'write', impt, true );\n                return impt();\n            }\n            return new ( asyncEval ? ( async function() {} ).constructor : Function )( $qIdentifier, source.toString() );\n        };\n        return _await( $eval( compilation.identifier + '', compilation ), main => {\n            const createRuntime = ( thisContext, $env = env ) => {\n                let $main = main;\n                if ( thisContext ) { $main = $main.bind( thisContext ); }\n                // There's always a global scope\n                let contextType = 'global', scope = new Scope( undefined, contextType, globalThis );\n                // Then this, for script scope, which may also directly reflect/mutate any provided \"env\"\n                if ( sourceType.endsWith( 'script' ) || $env ) { contextType = 'env'; scope = new Scope( scope, contextType, $env ); }\n                // Or this for module scope. And where \"env\" was provided, the \"env\" scope above too\n                if ( sourceType === 'module' ) { contextType = 'module'; scope = new Scope( scope, contextType ); }\n                if ( typeof thisContext !== 'undefined' ) { scope = new Scope( scope, 'this', { [ 'this' ]: thisContext } ); }\n                return new Runtime( undefined, contextType, { ...runtimeParams, originalSource: compilation.originalSource, executionMode: compilation.isQuantumProgram && 'QuantumProgram' || 'RegularProgram' }, scope, $main );\n            };\n            return isFunction\n                ? createRuntime().execute() // Produces the actual stateful function designed above\n                : { createRuntime, compilation };\n        } );\n    } );\n}", "\n/**\n * @imports\n */\nimport { _await } from './util.js';\nimport { $eval, State } from './runtime/index.js';\n\n/**\n * @Script\n */\nexport default class AbstractQuantumScript {\n    constructor( ...args ) {\n        const $static = this.constructor;\n        const params = typeof args[ args.length - 1 ] === 'object' ? args.pop() : {};\n        const source = args.pop() || '';\n        this.$program = $eval( $static.sourceType, $static.parseCompileCallback, source, params );\n    }\n\n    execute() { return _await( this.$program, ( { createRuntime } ) => createRuntime().execute() ); }\n\n    bind( thisContext, env = undefined ) { return _await( this.$program, ( { createRuntime } ) => createRuntime( thisContext, env ) ); }\n\n    toString( $qSource = false ) {\n        return _await( this.$program, ( { compilation } ) => {\n            if ( $qSource ) return compilation + '';\n            return compilation.originalSource;\n        } );\n    }\n}", "\n/**\n * @imports\n */\nimport * as QuantumJS from './index.lite.js';\n\n// As globals\nif ( !globalThis.webqit ) { self.webqit = {}; }\nObject.assign( globalThis.webqit, QuantumJS );\n"],
  "mappings": "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",
  "names": ["index_lite_exports", "__export", "AsyncQuantumFunction", "AsyncQuantumScript", "src_default", "QuantumAsyncFunction", "QuantumAsyncScript", "QuantumFunction", "QuantumModule", "QuantumScript", "State", "main_exports", "__export", "any", "apply", "batch", "construct", "defineProperties", "defineProperty", "deleteProperties", "deleteProperty", "get", "getOwnPropertyDescriptor", "getOwnPropertyDescriptors", "getPrototypeOf", "has", "intercept", "isExtensible", "map", "observe", "ownKeys", "path", "preventExtensions", "reduce", "set", "setPrototypeOf", "subtree", "isObject_default", "val", "getType_default", "val", "isArray_default", "val", "isTypeFunction_default", "val", "isNull_default", "val", "isUndefined_default", "val", "isTypeObject_default", "val", "isTypeFunction_default", "isEmpty_default", "val", "isNull_default", "isUndefined_default", "isTypeObject_default", "isFunction_default", "val", "isTypeFunction_default", "isString_default", "val", "isTypeArray_default", "val", "isString_default", "isUndefined_default", "wq", "obj", "namespaces", "WQInternals", "_ns", "_wq", "from_default", "val", "castObject", "isArray_default", "isObject_default", "isEmpty_default", "isTypeArray_default", "_wq", "target", "args", "wq", "_await", "value", "callback", "env", "Registration", "registry", "dfn", "ListenerRegistration", "Registration", "env", "events", "matches", "filter", "from_default", "event", "$ret", "_await", "ret", "recursions", "Registry", "target", "registration", "_entry", "type", "createIfNotExists", "namespace", "isTypeObject_default", "getType_default", "ImplementationClass", "_wq", "Descriptor", "target", "dfn", "ListenerRegistry", "Registry", "target", "createIfNotExists", "namespace", "ImplementationClass", "filter", "emit", "params", "ListenerRegistration", "events", "eventsArePropertyDescriptors", "eventIsArrayMethodDescriptor", "arrayMethodName", "listeners", "snapshots", "listenersLength", "listenersAskingEventsWithPropertyDescriptors", "listenersAskingArrayMethodDescriptors", "listener", "events_with_PropertyDescriptors_with_ArrayMethodDescriptors", "events_with_PropertyDescriptors_without_ArrayMethodDescriptors", "events_without_PropertyDescriptors_with_ArrayMethodDescriptors", "events_without_PropertyDescriptors_without_ArrayMethodDescriptors", "snapshot", "event", "$event", "type", "details", "Descriptor", "callback", "returnValue", "_await", "batch", "TrapsRegistration", "Registration", "descriptor", "next", "recieved", "args", "TrapsRegistry", "Registry", "target", "createIfNotExists", "namespace", "ImplementationClass", "dfn", "TrapsRegistration", "descriptor", "defaultHandler", "$this", "next", "index", "_args", "registration", "args", "actors_exports", "__export", "accessorize", "proxy", "unaccessorize", "unproxy", "symWQOriginal", "accessorize", "target", "props", "params", "resolveTarget", "accessorizedProps", "_wq", "getDescriptorDeep", "prop", "descriptor", "proto", "accessorizeProp", "currentDescriptorRecord", "withPropertyDescriptors", "value", "currentDescriptor", "accessorization", "enumerable", "set", "get", "statuses", "unaccessorize", "unaccessorizeProp", "proxy", "extendCallback", "originalTarget", "traps", "thisArgument", "argumentsList", "apply", "newTarget", "construct", "propertyKey", "attributes", "defineProperty", "deleteProperty", "receiver", "$params", "returnValue", "getOwnPropertyDescriptor", "getPrototypeOf", "has", "isExtensible", "ownKeys", "preventExtensions", "prototype", "setPrototypeOf", "$traps", "$proxy", "unproxy", "isTypeObject_default", "Path", "path", "segments", "Subtree", "subtree", "any", "reduce", "target", "receiver", "final", "x", "params", "_isSubtree", "eat", "$params", "$isSubtree", "isSubtree", "segment", "isLastSegment", "Descriptor", "result", "args", "addTrail", "desc", "flags", "advance", "$value", "resolveObj", "_await", "isPropsList", "entry", "observe", "prop", "originalTarget", "isFunction_default", "getType_default", "isTypeObject_default", "get", "emit", "bind", "intercept", "traps", "isObject_default", "TrapsRegistry", "getOwnPropertyDescriptor", "exec", "getOwnPropertyDescriptors", "getPrototypeOf", "isExtensible", "ownKeys", "has", "isLive", "resolveProps", "props", "related", "next", "results", "_props", "_done", "defaultGet", "descriptor", "value", "_next", "accessorizedProps", "_wq", "accessorization", "trapsRegistry", "result_s", "batch", "callback", "ListenerRegistry", "map", "source", "only", "except", "sourceKeys", "k", "filteredKeys", "resolveKey", "i", "doSet", "key", "set", "defineProperty", "mutations", "m", "deleteProperty", "def", "entries", "descriptors", "defaultSet", "status", "isUpdate", "oldValue", "exists", "listenerRegistry", "opr", "defineProperties", "from_default", "defaultDel", "deleteProperties", "construct", "argumentsList", "newTarget", "apply", "thisArgument", "originalThis", "unproxy", "returnValue", "setPrototypeOf", "proto", "preventExtensions", "controller", "env", "childRegistrations", "descriptor_s", "prevRegistration", "registrationNext", "isExisting", "handlerReturnValue", "operation", "payload", "defaultExec", "obj", "assert", "probePropertyDescriptors", "Observer", "main_exports", "actors_exports", "src_default", "_call", "_function", "args", "callback", "_await", "e", "maybePromise", "_isTypeObject", "val", "_$functionArgs", "params", "source", "env", "resolveParams", "extensions", "extension", "params", "runtimeParams", "compilerParams", "parserParams", "_runtimeParams", "_globalsNoObserve", "_globalsOnlyPathsExcept", "_compilerParams", "_parserParams", "registry", "_EventTarget", "env", "evenName", "args", "total", "x", "Signal", "_EventTarget", "context", "type", "state", "k", "name", "signal", "_isTypeObject", "src_default", "autorun", "flag", "mutations", "groupings", "autoruns", "mutation", "runtimesMap", "a", "b", "runtime", "newState", "Scope", "Signal", "context", "type", "state", "Autorun", "_EventTarget", "context", "type", "spec", "serial", "scope", "closure", "node", "a", "b", "prev", "key", "i", "flowControlBefore", "callback", "_await", "stateBefore", "_call", "returnValue", "exception", "e", "serials", "errorCode", "message", "$message", "cause", "x", "ErrorClass", "error", "fileName", "flowControlAfter", "cmd", "as", "value", "name", "valueType", "$closure", "args", "complete", "autorun", "src_default", "symbolState", "assignedValue", "lexicalScope", "valueBefore", "rest", "depth", "hint", "kind", "baseSignal", "val", "quantumMode", "isConst", "isRuntime", "isAborted", "isStatic", "nowRunning", "proxy", "signal", "propertyAlreadyBound", "traps", "target", "receiver", "AutorunClass", "staticDefs", "Scope", "executionMode", "functionKind", "$qFunction", "_this", "$qSource", "originalSource", "classKind", "$class", "methodsSpec", "isQuantumFunction", "label", "arg", "unset", "sizeBefore", "sizeAfter", "downstream", "nextRound", "returnees", "total", "AutoIterator", "Autorun", "context", "type", "spec", "serial", "scope", "closure", "callback", "_await", "returnValue", "key", "val", "$test", "$round", "production", "index", "state", "Scope", "meta", "name", "round", "handleMutations", "mutations", "currentCursor", "deletions", "extension", "mutation", "existingRound", "src_default", "deletion", "parent", "AutoAsyncIterator", "AutoIterator", "key", "val", "cursor", "$test", "$round", "State", "runtime", "events", "src_default", "name", "Runtime", "Autorun", "context", "type", "params", "scope", "closure", "$serial", "spec", "$params", "Scope", "src_default", "serial", "full", "locStart", "line", "column", "locEnd", "expr", "autoruns", "isActive", "autorun", "nextTick", "prevReturn", "current", "following", "returnValue", "callback", "actualReturnValue", "State", "executionMode", "thisContext", "lexicalContext", "args", "source", "$source", "onload", "modules", "registry", "promise", "moduleName", "e", "specifiers", "target", "sourceSerial", "observeList", "quantumMode", "local", "alias", "mutations", "mutation", "__publicField", "AutoAsyncIterator", "AutoIterator", "$eval", "sourceType", "parseCompileCallback", "source", "params", "env", "functionParams", "exportNamespace", "fileName", "parserParams", "compilerParams", "runtimeParams", "resolveParams", "inBrowser", "asyncEval", "body", "compilation", "_await", "isFunction", "$qIdentifier", "dataUrl", "m", "main", "createRuntime", "thisContext", "$env", "$main", "contextType", "scope", "Scope", "Runtime", "AbstractQuantumScript", "args", "$static", "params", "source", "$eval", "_await", "createRuntime", "thisContext", "env", "$qSource", "compilation", "QuantumFunction", "AsyncQuantumFunction", "args", "source", "params", "_$functionArgs", "compiledFunction", "$eval", "parseCompileCallback", "wrapperFunction", "QuantumAsyncFunction", "QuantumScript", "AsyncQuantumScript", "AbstractQuantumScript", "__publicField", "QuantumAsyncScript", "QuantumModule", "parse", "compile", "ast", "workerScriptText", "res", "messageChannel", "e", "compilation", "base64", "index_lite_exports"]
}
